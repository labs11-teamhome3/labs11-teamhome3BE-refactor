// Code generated by Prisma (prisma@1.29.2). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  document: (where?: DocumentWhereInput) => Promise<boolean>;
  documentComment: (where?: DocumentCommentWhereInput) => Promise<boolean>;
  event: (where?: EventWhereInput) => Promise<boolean>;
  folder: (where?: FolderWhereInput) => Promise<boolean>;
  message: (where?: MessageWhereInput) => Promise<boolean>;
  messageComment: (where?: MessageCommentWhereInput) => Promise<boolean>;
  tag: (where?: TagWhereInput) => Promise<boolean>;
  team: (where?: TeamWhereInput) => Promise<boolean>;
  todo: (where?: TodoWhereInput) => Promise<boolean>;
  todoList: (where?: TodoListWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  document: (where: DocumentWhereUniqueInput) => DocumentPromise;
  documents: (
    args?: {
      where?: DocumentWhereInput;
      orderBy?: DocumentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Document>;
  documentsConnection: (
    args?: {
      where?: DocumentWhereInput;
      orderBy?: DocumentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => DocumentConnectionPromise;
  documentComment: (
    where: DocumentCommentWhereUniqueInput
  ) => DocumentCommentPromise;
  documentComments: (
    args?: {
      where?: DocumentCommentWhereInput;
      orderBy?: DocumentCommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<DocumentComment>;
  documentCommentsConnection: (
    args?: {
      where?: DocumentCommentWhereInput;
      orderBy?: DocumentCommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => DocumentCommentConnectionPromise;
  event: (where: EventWhereUniqueInput) => EventPromise;
  events: (
    args?: {
      where?: EventWhereInput;
      orderBy?: EventOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Event>;
  eventsConnection: (
    args?: {
      where?: EventWhereInput;
      orderBy?: EventOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => EventConnectionPromise;
  folder: (where: FolderWhereUniqueInput) => FolderPromise;
  folders: (
    args?: {
      where?: FolderWhereInput;
      orderBy?: FolderOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Folder>;
  foldersConnection: (
    args?: {
      where?: FolderWhereInput;
      orderBy?: FolderOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FolderConnectionPromise;
  message: (where: MessageWhereUniqueInput) => MessagePromise;
  messages: (
    args?: {
      where?: MessageWhereInput;
      orderBy?: MessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Message>;
  messagesConnection: (
    args?: {
      where?: MessageWhereInput;
      orderBy?: MessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => MessageConnectionPromise;
  messageComment: (
    where: MessageCommentWhereUniqueInput
  ) => MessageCommentPromise;
  messageComments: (
    args?: {
      where?: MessageCommentWhereInput;
      orderBy?: MessageCommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<MessageComment>;
  messageCommentsConnection: (
    args?: {
      where?: MessageCommentWhereInput;
      orderBy?: MessageCommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => MessageCommentConnectionPromise;
  tag: (where: TagWhereUniqueInput) => TagPromise;
  tags: (
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Tag>;
  tagsConnection: (
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TagConnectionPromise;
  team: (where: TeamWhereUniqueInput) => TeamPromise;
  teams: (
    args?: {
      where?: TeamWhereInput;
      orderBy?: TeamOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Team>;
  teamsConnection: (
    args?: {
      where?: TeamWhereInput;
      orderBy?: TeamOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TeamConnectionPromise;
  todo: (where: TodoWhereUniqueInput) => TodoPromise;
  todoes: (
    args?: {
      where?: TodoWhereInput;
      orderBy?: TodoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Todo>;
  todoesConnection: (
    args?: {
      where?: TodoWhereInput;
      orderBy?: TodoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TodoConnectionPromise;
  todoList: (where: TodoListWhereUniqueInput) => TodoListPromise;
  todoLists: (
    args?: {
      where?: TodoListWhereInput;
      orderBy?: TodoListOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<TodoList>;
  todoListsConnection: (
    args?: {
      where?: TodoListWhereInput;
      orderBy?: TodoListOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TodoListConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createDocument: (data: DocumentCreateInput) => DocumentPromise;
  updateDocument: (
    args: { data: DocumentUpdateInput; where: DocumentWhereUniqueInput }
  ) => DocumentPromise;
  updateManyDocuments: (
    args: { data: DocumentUpdateManyMutationInput; where?: DocumentWhereInput }
  ) => BatchPayloadPromise;
  upsertDocument: (
    args: {
      where: DocumentWhereUniqueInput;
      create: DocumentCreateInput;
      update: DocumentUpdateInput;
    }
  ) => DocumentPromise;
  deleteDocument: (where: DocumentWhereUniqueInput) => DocumentPromise;
  deleteManyDocuments: (where?: DocumentWhereInput) => BatchPayloadPromise;
  createDocumentComment: (
    data: DocumentCommentCreateInput
  ) => DocumentCommentPromise;
  updateDocumentComment: (
    args: {
      data: DocumentCommentUpdateInput;
      where: DocumentCommentWhereUniqueInput;
    }
  ) => DocumentCommentPromise;
  updateManyDocumentComments: (
    args: {
      data: DocumentCommentUpdateManyMutationInput;
      where?: DocumentCommentWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertDocumentComment: (
    args: {
      where: DocumentCommentWhereUniqueInput;
      create: DocumentCommentCreateInput;
      update: DocumentCommentUpdateInput;
    }
  ) => DocumentCommentPromise;
  deleteDocumentComment: (
    where: DocumentCommentWhereUniqueInput
  ) => DocumentCommentPromise;
  deleteManyDocumentComments: (
    where?: DocumentCommentWhereInput
  ) => BatchPayloadPromise;
  createEvent: (data: EventCreateInput) => EventPromise;
  updateEvent: (
    args: { data: EventUpdateInput; where: EventWhereUniqueInput }
  ) => EventPromise;
  updateManyEvents: (
    args: { data: EventUpdateManyMutationInput; where?: EventWhereInput }
  ) => BatchPayloadPromise;
  upsertEvent: (
    args: {
      where: EventWhereUniqueInput;
      create: EventCreateInput;
      update: EventUpdateInput;
    }
  ) => EventPromise;
  deleteEvent: (where: EventWhereUniqueInput) => EventPromise;
  deleteManyEvents: (where?: EventWhereInput) => BatchPayloadPromise;
  createFolder: (data: FolderCreateInput) => FolderPromise;
  updateFolder: (
    args: { data: FolderUpdateInput; where: FolderWhereUniqueInput }
  ) => FolderPromise;
  updateManyFolders: (
    args: { data: FolderUpdateManyMutationInput; where?: FolderWhereInput }
  ) => BatchPayloadPromise;
  upsertFolder: (
    args: {
      where: FolderWhereUniqueInput;
      create: FolderCreateInput;
      update: FolderUpdateInput;
    }
  ) => FolderPromise;
  deleteFolder: (where: FolderWhereUniqueInput) => FolderPromise;
  deleteManyFolders: (where?: FolderWhereInput) => BatchPayloadPromise;
  createMessage: (data: MessageCreateInput) => MessagePromise;
  updateMessage: (
    args: { data: MessageUpdateInput; where: MessageWhereUniqueInput }
  ) => MessagePromise;
  updateManyMessages: (
    args: { data: MessageUpdateManyMutationInput; where?: MessageWhereInput }
  ) => BatchPayloadPromise;
  upsertMessage: (
    args: {
      where: MessageWhereUniqueInput;
      create: MessageCreateInput;
      update: MessageUpdateInput;
    }
  ) => MessagePromise;
  deleteMessage: (where: MessageWhereUniqueInput) => MessagePromise;
  deleteManyMessages: (where?: MessageWhereInput) => BatchPayloadPromise;
  createMessageComment: (
    data: MessageCommentCreateInput
  ) => MessageCommentPromise;
  updateMessageComment: (
    args: {
      data: MessageCommentUpdateInput;
      where: MessageCommentWhereUniqueInput;
    }
  ) => MessageCommentPromise;
  updateManyMessageComments: (
    args: {
      data: MessageCommentUpdateManyMutationInput;
      where?: MessageCommentWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertMessageComment: (
    args: {
      where: MessageCommentWhereUniqueInput;
      create: MessageCommentCreateInput;
      update: MessageCommentUpdateInput;
    }
  ) => MessageCommentPromise;
  deleteMessageComment: (
    where: MessageCommentWhereUniqueInput
  ) => MessageCommentPromise;
  deleteManyMessageComments: (
    where?: MessageCommentWhereInput
  ) => BatchPayloadPromise;
  createTag: (data: TagCreateInput) => TagPromise;
  updateTag: (
    args: { data: TagUpdateInput; where: TagWhereUniqueInput }
  ) => TagPromise;
  updateManyTags: (
    args: { data: TagUpdateManyMutationInput; where?: TagWhereInput }
  ) => BatchPayloadPromise;
  upsertTag: (
    args: {
      where: TagWhereUniqueInput;
      create: TagCreateInput;
      update: TagUpdateInput;
    }
  ) => TagPromise;
  deleteTag: (where: TagWhereUniqueInput) => TagPromise;
  deleteManyTags: (where?: TagWhereInput) => BatchPayloadPromise;
  createTeam: (data: TeamCreateInput) => TeamPromise;
  updateTeam: (
    args: { data: TeamUpdateInput; where: TeamWhereUniqueInput }
  ) => TeamPromise;
  updateManyTeams: (
    args: { data: TeamUpdateManyMutationInput; where?: TeamWhereInput }
  ) => BatchPayloadPromise;
  upsertTeam: (
    args: {
      where: TeamWhereUniqueInput;
      create: TeamCreateInput;
      update: TeamUpdateInput;
    }
  ) => TeamPromise;
  deleteTeam: (where: TeamWhereUniqueInput) => TeamPromise;
  deleteManyTeams: (where?: TeamWhereInput) => BatchPayloadPromise;
  createTodo: (data: TodoCreateInput) => TodoPromise;
  updateTodo: (
    args: { data: TodoUpdateInput; where: TodoWhereUniqueInput }
  ) => TodoPromise;
  updateManyTodoes: (
    args: { data: TodoUpdateManyMutationInput; where?: TodoWhereInput }
  ) => BatchPayloadPromise;
  upsertTodo: (
    args: {
      where: TodoWhereUniqueInput;
      create: TodoCreateInput;
      update: TodoUpdateInput;
    }
  ) => TodoPromise;
  deleteTodo: (where: TodoWhereUniqueInput) => TodoPromise;
  deleteManyTodoes: (where?: TodoWhereInput) => BatchPayloadPromise;
  createTodoList: (data: TodoListCreateInput) => TodoListPromise;
  updateTodoList: (
    args: { data: TodoListUpdateInput; where: TodoListWhereUniqueInput }
  ) => TodoListPromise;
  updateManyTodoLists: (
    args: { data: TodoListUpdateManyMutationInput; where?: TodoListWhereInput }
  ) => BatchPayloadPromise;
  upsertTodoList: (
    args: {
      where: TodoListWhereUniqueInput;
      create: TodoListCreateInput;
      update: TodoListUpdateInput;
    }
  ) => TodoListPromise;
  deleteTodoList: (where: TodoListWhereUniqueInput) => TodoListPromise;
  deleteManyTodoLists: (where?: TodoListWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  document: (
    where?: DocumentSubscriptionWhereInput
  ) => DocumentSubscriptionPayloadSubscription;
  documentComment: (
    where?: DocumentCommentSubscriptionWhereInput
  ) => DocumentCommentSubscriptionPayloadSubscription;
  event: (
    where?: EventSubscriptionWhereInput
  ) => EventSubscriptionPayloadSubscription;
  folder: (
    where?: FolderSubscriptionWhereInput
  ) => FolderSubscriptionPayloadSubscription;
  message: (
    where?: MessageSubscriptionWhereInput
  ) => MessageSubscriptionPayloadSubscription;
  messageComment: (
    where?: MessageCommentSubscriptionWhereInput
  ) => MessageCommentSubscriptionPayloadSubscription;
  tag: (
    where?: TagSubscriptionWhereInput
  ) => TagSubscriptionPayloadSubscription;
  team: (
    where?: TeamSubscriptionWhereInput
  ) => TeamSubscriptionPayloadSubscription;
  todo: (
    where?: TodoSubscriptionWhereInput
  ) => TodoSubscriptionPayloadSubscription;
  todoList: (
    where?: TodoListSubscriptionWhereInput
  ) => TodoListSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type TodoListOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "description_ASC"
  | "description_DESC"
  | "completed_ASC"
  | "completed_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "authId_ASC"
  | "authId_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TodoOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "description_ASC"
  | "description_DESC"
  | "completed_ASC"
  | "completed_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MessageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "content_ASC"
  | "content_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MessageCommentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "content_ASC"
  | "content_DESC"
  | "image_ASC"
  | "image_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type EventOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "action_string_ASC"
  | "action_string_DESC"
  | "object_string_ASC"
  | "object_string_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TagOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type DocumentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "doc_url_ASC"
  | "doc_url_DESC"
  | "title_ASC"
  | "title_DESC"
  | "textContent_ASC"
  | "textContent_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FolderOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TeamOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "teamName_ASC"
  | "teamName_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type DocumentCommentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "content_ASC"
  | "content_DESC"
  | "image_ASC"
  | "image_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type DocumentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface TodoListWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  ownedBy_every?: UserWhereInput;
  ownedBy_some?: UserWhereInput;
  ownedBy_none?: UserWhereInput;
  assignedTo_every?: UserWhereInput;
  assignedTo_some?: UserWhereInput;
  assignedTo_none?: UserWhereInput;
  todos_every?: TodoWhereInput;
  todos_some?: TodoWhereInput;
  todos_none?: TodoWhereInput;
  completed?: Boolean;
  completed_not?: Boolean;
  inTeam?: TeamWhereInput;
  AND?: TodoListWhereInput[] | TodoListWhereInput;
  OR?: TodoListWhereInput[] | TodoListWhereInput;
  NOT?: TodoListWhereInput[] | TodoListWhereInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  authId?: String;
  authId_not?: String;
  authId_in?: String[] | String;
  authId_not_in?: String[] | String;
  authId_lt?: String;
  authId_lte?: String;
  authId_gt?: String;
  authId_gte?: String;
  authId_contains?: String;
  authId_not_contains?: String;
  authId_starts_with?: String;
  authId_not_starts_with?: String;
  authId_ends_with?: String;
  authId_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  todoListsOwned_every?: TodoListWhereInput;
  todoListsOwned_some?: TodoListWhereInput;
  todoListsOwned_none?: TodoListWhereInput;
  todoListsAssigned_every?: TodoListWhereInput;
  todoListsAssigned_some?: TodoListWhereInput;
  todoListsAssigned_none?: TodoListWhereInput;
  inTeam_every?: TeamWhereInput;
  inTeam_some?: TeamWhereInput;
  inTeam_none?: TeamWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface TeamWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  teamName?: String;
  teamName_not?: String;
  teamName_in?: String[] | String;
  teamName_not_in?: String[] | String;
  teamName_lt?: String;
  teamName_lte?: String;
  teamName_gt?: String;
  teamName_gte?: String;
  teamName_contains?: String;
  teamName_not_contains?: String;
  teamName_starts_with?: String;
  teamName_not_starts_with?: String;
  teamName_ends_with?: String;
  teamName_not_ends_with?: String;
  members_every?: UserWhereInput;
  members_some?: UserWhereInput;
  members_none?: UserWhereInput;
  todoLists_every?: TodoListWhereInput;
  todoLists_some?: TodoListWhereInput;
  todoLists_none?: TodoListWhereInput;
  messages_every?: MessageWhereInput;
  messages_some?: MessageWhereInput;
  messages_none?: MessageWhereInput;
  events_every?: EventWhereInput;
  events_some?: EventWhereInput;
  events_none?: EventWhereInput;
  tags_every?: TagWhereInput;
  tags_some?: TagWhereInput;
  tags_none?: TagWhereInput;
  documents_every?: DocumentWhereInput;
  documents_some?: DocumentWhereInput;
  documents_none?: DocumentWhereInput;
  folders_every?: FolderWhereInput;
  folders_some?: FolderWhereInput;
  folders_none?: FolderWhereInput;
  AND?: TeamWhereInput[] | TeamWhereInput;
  OR?: TeamWhereInput[] | TeamWhereInput;
  NOT?: TeamWhereInput[] | TeamWhereInput;
}

export interface MessageWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  creator?: UserWhereInput;
  inTeam?: TeamWhereInput;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  tag?: TagWhereInput;
  comments_every?: MessageCommentWhereInput;
  comments_some?: MessageCommentWhereInput;
  comments_none?: MessageCommentWhereInput;
  subscribedUsers_every?: UserWhereInput;
  subscribedUsers_some?: UserWhereInput;
  subscribedUsers_none?: UserWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: MessageWhereInput[] | MessageWhereInput;
  OR?: MessageWhereInput[] | MessageWhereInput;
  NOT?: MessageWhereInput[] | MessageWhereInput;
}

export interface TagWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  team?: TeamWhereInput;
  AND?: TagWhereInput[] | TagWhereInput;
  OR?: TagWhereInput[] | TagWhereInput;
  NOT?: TagWhereInput[] | TagWhereInput;
}

export interface MessageCommentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  user?: UserWhereInput;
  message?: MessageWhereInput;
  image?: String;
  image_not?: String;
  image_in?: String[] | String;
  image_not_in?: String[] | String;
  image_lt?: String;
  image_lte?: String;
  image_gt?: String;
  image_gte?: String;
  image_contains?: String;
  image_not_contains?: String;
  image_starts_with?: String;
  image_not_starts_with?: String;
  image_ends_with?: String;
  image_not_ends_with?: String;
  likes_every?: UserWhereInput;
  likes_some?: UserWhereInput;
  likes_none?: UserWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: MessageCommentWhereInput[] | MessageCommentWhereInput;
  OR?: MessageCommentWhereInput[] | MessageCommentWhereInput;
  NOT?: MessageCommentWhereInput[] | MessageCommentWhereInput;
}

export interface EventWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  team?: TeamWhereInput;
  user?: UserWhereInput;
  action_string?: String;
  action_string_not?: String;
  action_string_in?: String[] | String;
  action_string_not_in?: String[] | String;
  action_string_lt?: String;
  action_string_lte?: String;
  action_string_gt?: String;
  action_string_gte?: String;
  action_string_contains?: String;
  action_string_not_contains?: String;
  action_string_starts_with?: String;
  action_string_not_starts_with?: String;
  action_string_ends_with?: String;
  action_string_not_ends_with?: String;
  object_string?: String;
  object_string_not?: String;
  object_string_in?: String[] | String;
  object_string_not_in?: String[] | String;
  object_string_lt?: String;
  object_string_lte?: String;
  object_string_gt?: String;
  object_string_gte?: String;
  object_string_contains?: String;
  object_string_not_contains?: String;
  object_string_starts_with?: String;
  object_string_not_starts_with?: String;
  object_string_ends_with?: String;
  object_string_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: EventWhereInput[] | EventWhereInput;
  OR?: EventWhereInput[] | EventWhereInput;
  NOT?: EventWhereInput[] | EventWhereInput;
}

export interface DocumentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  doc_url?: String;
  doc_url_not?: String;
  doc_url_in?: String[] | String;
  doc_url_not_in?: String[] | String;
  doc_url_lt?: String;
  doc_url_lte?: String;
  doc_url_gt?: String;
  doc_url_gte?: String;
  doc_url_contains?: String;
  doc_url_not_contains?: String;
  doc_url_starts_with?: String;
  doc_url_not_starts_with?: String;
  doc_url_ends_with?: String;
  doc_url_not_ends_with?: String;
  user?: UserWhereInput;
  folder?: FolderWhereInput;
  team?: TeamWhereInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  textContent?: String;
  textContent_not?: String;
  textContent_in?: String[] | String;
  textContent_not_in?: String[] | String;
  textContent_lt?: String;
  textContent_lte?: String;
  textContent_gt?: String;
  textContent_gte?: String;
  textContent_contains?: String;
  textContent_not_contains?: String;
  textContent_starts_with?: String;
  textContent_not_starts_with?: String;
  textContent_ends_with?: String;
  textContent_not_ends_with?: String;
  tag?: TagWhereInput;
  comments_every?: DocumentCommentWhereInput;
  comments_some?: DocumentCommentWhereInput;
  comments_none?: DocumentCommentWhereInput;
  subscribedUsers_every?: UserWhereInput;
  subscribedUsers_some?: UserWhereInput;
  subscribedUsers_none?: UserWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: DocumentWhereInput[] | DocumentWhereInput;
  OR?: DocumentWhereInput[] | DocumentWhereInput;
  NOT?: DocumentWhereInput[] | DocumentWhereInput;
}

export interface FolderWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  user?: UserWhereInput;
  team?: TeamWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  documents_every?: DocumentWhereInput;
  documents_some?: DocumentWhereInput;
  documents_none?: DocumentWhereInput;
  AND?: FolderWhereInput[] | FolderWhereInput;
  OR?: FolderWhereInput[] | FolderWhereInput;
  NOT?: FolderWhereInput[] | FolderWhereInput;
}

export interface DocumentCommentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  user?: UserWhereInput;
  document?: DocumentWhereInput;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  image?: String;
  image_not?: String;
  image_in?: String[] | String;
  image_not_in?: String[] | String;
  image_lt?: String;
  image_lte?: String;
  image_gt?: String;
  image_gte?: String;
  image_contains?: String;
  image_not_contains?: String;
  image_starts_with?: String;
  image_not_starts_with?: String;
  image_ends_with?: String;
  image_not_ends_with?: String;
  likes_every?: UserWhereInput;
  likes_some?: UserWhereInput;
  likes_none?: UserWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: DocumentCommentWhereInput[] | DocumentCommentWhereInput;
  OR?: DocumentCommentWhereInput[] | DocumentCommentWhereInput;
  NOT?: DocumentCommentWhereInput[] | DocumentCommentWhereInput;
}

export interface TodoWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  partOf?: TodoListWhereInput;
  completed?: Boolean;
  completed_not?: Boolean;
  AND?: TodoWhereInput[] | TodoWhereInput;
  OR?: TodoWhereInput[] | TodoWhereInput;
  NOT?: TodoWhereInput[] | TodoWhereInput;
}

export type DocumentCommentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type EventWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type FolderWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type MessageWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type MessageCommentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type TagWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type TeamWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type TodoWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type TodoListWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  authId?: String;
}>;

export interface DocumentCreateInput {
  doc_url: String;
  user: UserCreateOneInput;
  folder?: FolderCreateOneWithoutDocumentsInput;
  team: TeamCreateOneWithoutDocumentsInput;
  title: String;
  textContent: String;
  tag?: TagCreateOneInput;
  images?: DocumentCreateimagesInput;
  comments?: DocumentCommentCreateManyWithoutDocumentInput;
  subscribedUsers?: UserCreateManyInput;
}

export interface UserCreateOneInput {
  create?: UserCreateInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateInput {
  authId?: String;
  name?: String;
  todoListsOwned?: TodoListCreateManyWithoutOwnedByInput;
  todoListsAssigned?: TodoListCreateManyWithoutAssignedToInput;
  inTeam?: TeamCreateManyWithoutMembersInput;
}

export interface TodoListCreateManyWithoutOwnedByInput {
  create?:
    | TodoListCreateWithoutOwnedByInput[]
    | TodoListCreateWithoutOwnedByInput;
  connect?: TodoListWhereUniqueInput[] | TodoListWhereUniqueInput;
}

export interface TodoListCreateWithoutOwnedByInput {
  description: String;
  assignedTo?: UserCreateManyWithoutTodoListsAssignedInput;
  todos?: TodoCreateManyWithoutPartOfInput;
  completed?: Boolean;
  inTeam?: TeamCreateOneWithoutTodoListsInput;
}

export interface UserCreateManyWithoutTodoListsAssignedInput {
  create?:
    | UserCreateWithoutTodoListsAssignedInput[]
    | UserCreateWithoutTodoListsAssignedInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserCreateWithoutTodoListsAssignedInput {
  authId?: String;
  name?: String;
  todoListsOwned?: TodoListCreateManyWithoutOwnedByInput;
  inTeam?: TeamCreateManyWithoutMembersInput;
}

export interface TeamCreateManyWithoutMembersInput {
  create?: TeamCreateWithoutMembersInput[] | TeamCreateWithoutMembersInput;
  connect?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
}

export interface TeamCreateWithoutMembersInput {
  teamName: String;
  todoLists?: TodoListCreateManyWithoutInTeamInput;
  messages?: MessageCreateManyWithoutInTeamInput;
  events?: EventCreateManyWithoutTeamInput;
  tags?: TagCreateManyWithoutTeamInput;
  documents?: DocumentCreateManyWithoutTeamInput;
  folders?: FolderCreateManyWithoutTeamInput;
}

export interface TodoListCreateManyWithoutInTeamInput {
  create?:
    | TodoListCreateWithoutInTeamInput[]
    | TodoListCreateWithoutInTeamInput;
  connect?: TodoListWhereUniqueInput[] | TodoListWhereUniqueInput;
}

export interface TodoListCreateWithoutInTeamInput {
  description: String;
  ownedBy?: UserCreateManyWithoutTodoListsOwnedInput;
  assignedTo?: UserCreateManyWithoutTodoListsAssignedInput;
  todos?: TodoCreateManyWithoutPartOfInput;
  completed?: Boolean;
}

export interface UserCreateManyWithoutTodoListsOwnedInput {
  create?:
    | UserCreateWithoutTodoListsOwnedInput[]
    | UserCreateWithoutTodoListsOwnedInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserCreateWithoutTodoListsOwnedInput {
  authId?: String;
  name?: String;
  todoListsAssigned?: TodoListCreateManyWithoutAssignedToInput;
  inTeam?: TeamCreateManyWithoutMembersInput;
}

export interface TodoListCreateManyWithoutAssignedToInput {
  create?:
    | TodoListCreateWithoutAssignedToInput[]
    | TodoListCreateWithoutAssignedToInput;
  connect?: TodoListWhereUniqueInput[] | TodoListWhereUniqueInput;
}

export interface TodoListCreateWithoutAssignedToInput {
  description: String;
  ownedBy?: UserCreateManyWithoutTodoListsOwnedInput;
  todos?: TodoCreateManyWithoutPartOfInput;
  completed?: Boolean;
  inTeam?: TeamCreateOneWithoutTodoListsInput;
}

export interface TodoCreateManyWithoutPartOfInput {
  create?: TodoCreateWithoutPartOfInput[] | TodoCreateWithoutPartOfInput;
  connect?: TodoWhereUniqueInput[] | TodoWhereUniqueInput;
}

export interface TodoCreateWithoutPartOfInput {
  description: String;
  completed?: Boolean;
}

export interface TeamCreateOneWithoutTodoListsInput {
  create?: TeamCreateWithoutTodoListsInput;
  connect?: TeamWhereUniqueInput;
}

export interface TeamCreateWithoutTodoListsInput {
  teamName: String;
  members?: UserCreateManyWithoutInTeamInput;
  messages?: MessageCreateManyWithoutInTeamInput;
  events?: EventCreateManyWithoutTeamInput;
  tags?: TagCreateManyWithoutTeamInput;
  documents?: DocumentCreateManyWithoutTeamInput;
  folders?: FolderCreateManyWithoutTeamInput;
}

export interface UserCreateManyWithoutInTeamInput {
  create?: UserCreateWithoutInTeamInput[] | UserCreateWithoutInTeamInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserCreateWithoutInTeamInput {
  authId?: String;
  name?: String;
  todoListsOwned?: TodoListCreateManyWithoutOwnedByInput;
  todoListsAssigned?: TodoListCreateManyWithoutAssignedToInput;
}

export interface MessageCreateManyWithoutInTeamInput {
  create?: MessageCreateWithoutInTeamInput[] | MessageCreateWithoutInTeamInput;
  connect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
}

export interface MessageCreateWithoutInTeamInput {
  title: String;
  creator: UserCreateOneInput;
  content: String;
  images?: MessageCreateimagesInput;
  tag?: TagCreateOneInput;
  comments?: MessageCommentCreateManyWithoutMessageInput;
  subscribedUsers?: UserCreateManyInput;
}

export interface MessageCreateimagesInput {
  set?: String[] | String;
}

export interface TagCreateOneInput {
  create?: TagCreateInput;
  connect?: TagWhereUniqueInput;
}

export interface TagCreateInput {
  name: String;
  team?: TeamCreateOneWithoutTagsInput;
}

export interface TeamCreateOneWithoutTagsInput {
  create?: TeamCreateWithoutTagsInput;
  connect?: TeamWhereUniqueInput;
}

export interface TeamCreateWithoutTagsInput {
  teamName: String;
  members?: UserCreateManyWithoutInTeamInput;
  todoLists?: TodoListCreateManyWithoutInTeamInput;
  messages?: MessageCreateManyWithoutInTeamInput;
  events?: EventCreateManyWithoutTeamInput;
  documents?: DocumentCreateManyWithoutTeamInput;
  folders?: FolderCreateManyWithoutTeamInput;
}

export interface EventCreateManyWithoutTeamInput {
  create?: EventCreateWithoutTeamInput[] | EventCreateWithoutTeamInput;
  connect?: EventWhereUniqueInput[] | EventWhereUniqueInput;
}

export interface EventCreateWithoutTeamInput {
  user?: UserCreateOneInput;
  action_string: String;
  object_string: String;
}

export interface DocumentCreateManyWithoutTeamInput {
  create?: DocumentCreateWithoutTeamInput[] | DocumentCreateWithoutTeamInput;
  connect?: DocumentWhereUniqueInput[] | DocumentWhereUniqueInput;
}

export interface DocumentCreateWithoutTeamInput {
  doc_url: String;
  user: UserCreateOneInput;
  folder?: FolderCreateOneWithoutDocumentsInput;
  title: String;
  textContent: String;
  tag?: TagCreateOneInput;
  images?: DocumentCreateimagesInput;
  comments?: DocumentCommentCreateManyWithoutDocumentInput;
  subscribedUsers?: UserCreateManyInput;
}

export interface FolderCreateOneWithoutDocumentsInput {
  create?: FolderCreateWithoutDocumentsInput;
  connect?: FolderWhereUniqueInput;
}

export interface FolderCreateWithoutDocumentsInput {
  title: String;
  user: UserCreateOneInput;
  team: TeamCreateOneWithoutFoldersInput;
}

export interface TeamCreateOneWithoutFoldersInput {
  create?: TeamCreateWithoutFoldersInput;
  connect?: TeamWhereUniqueInput;
}

export interface TeamCreateWithoutFoldersInput {
  teamName: String;
  members?: UserCreateManyWithoutInTeamInput;
  todoLists?: TodoListCreateManyWithoutInTeamInput;
  messages?: MessageCreateManyWithoutInTeamInput;
  events?: EventCreateManyWithoutTeamInput;
  tags?: TagCreateManyWithoutTeamInput;
  documents?: DocumentCreateManyWithoutTeamInput;
}

export interface TagCreateManyWithoutTeamInput {
  create?: TagCreateWithoutTeamInput[] | TagCreateWithoutTeamInput;
  connect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
}

export interface TagCreateWithoutTeamInput {
  name: String;
}

export interface DocumentCreateimagesInput {
  set?: String[] | String;
}

export interface DocumentCommentCreateManyWithoutDocumentInput {
  create?:
    | DocumentCommentCreateWithoutDocumentInput[]
    | DocumentCommentCreateWithoutDocumentInput;
  connect?: DocumentCommentWhereUniqueInput[] | DocumentCommentWhereUniqueInput;
}

export interface DocumentCommentCreateWithoutDocumentInput {
  user: UserCreateOneInput;
  content: String;
  image?: String;
  likes?: UserCreateManyInput;
}

export interface UserCreateManyInput {
  create?: UserCreateInput[] | UserCreateInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface FolderCreateManyWithoutTeamInput {
  create?: FolderCreateWithoutTeamInput[] | FolderCreateWithoutTeamInput;
  connect?: FolderWhereUniqueInput[] | FolderWhereUniqueInput;
}

export interface FolderCreateWithoutTeamInput {
  title: String;
  user: UserCreateOneInput;
  documents?: DocumentCreateManyWithoutFolderInput;
}

export interface DocumentCreateManyWithoutFolderInput {
  create?:
    | DocumentCreateWithoutFolderInput[]
    | DocumentCreateWithoutFolderInput;
  connect?: DocumentWhereUniqueInput[] | DocumentWhereUniqueInput;
}

export interface DocumentCreateWithoutFolderInput {
  doc_url: String;
  user: UserCreateOneInput;
  team: TeamCreateOneWithoutDocumentsInput;
  title: String;
  textContent: String;
  tag?: TagCreateOneInput;
  images?: DocumentCreateimagesInput;
  comments?: DocumentCommentCreateManyWithoutDocumentInput;
  subscribedUsers?: UserCreateManyInput;
}

export interface TeamCreateOneWithoutDocumentsInput {
  create?: TeamCreateWithoutDocumentsInput;
  connect?: TeamWhereUniqueInput;
}

export interface TeamCreateWithoutDocumentsInput {
  teamName: String;
  members?: UserCreateManyWithoutInTeamInput;
  todoLists?: TodoListCreateManyWithoutInTeamInput;
  messages?: MessageCreateManyWithoutInTeamInput;
  events?: EventCreateManyWithoutTeamInput;
  tags?: TagCreateManyWithoutTeamInput;
  folders?: FolderCreateManyWithoutTeamInput;
}

export interface MessageCommentCreateManyWithoutMessageInput {
  create?:
    | MessageCommentCreateWithoutMessageInput[]
    | MessageCommentCreateWithoutMessageInput;
  connect?: MessageCommentWhereUniqueInput[] | MessageCommentWhereUniqueInput;
}

export interface MessageCommentCreateWithoutMessageInput {
  content: String;
  user: UserCreateOneInput;
  image?: String;
  likes?: UserCreateManyInput;
}

export interface DocumentUpdateInput {
  doc_url?: String;
  user?: UserUpdateOneRequiredInput;
  folder?: FolderUpdateOneWithoutDocumentsInput;
  team?: TeamUpdateOneRequiredWithoutDocumentsInput;
  title?: String;
  textContent?: String;
  tag?: TagUpdateOneInput;
  images?: DocumentUpdateimagesInput;
  comments?: DocumentCommentUpdateManyWithoutDocumentInput;
  subscribedUsers?: UserUpdateManyInput;
}

export interface UserUpdateOneRequiredInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateDataInput {
  authId?: String;
  name?: String;
  todoListsOwned?: TodoListUpdateManyWithoutOwnedByInput;
  todoListsAssigned?: TodoListUpdateManyWithoutAssignedToInput;
  inTeam?: TeamUpdateManyWithoutMembersInput;
}

export interface TodoListUpdateManyWithoutOwnedByInput {
  create?:
    | TodoListCreateWithoutOwnedByInput[]
    | TodoListCreateWithoutOwnedByInput;
  delete?: TodoListWhereUniqueInput[] | TodoListWhereUniqueInput;
  connect?: TodoListWhereUniqueInput[] | TodoListWhereUniqueInput;
  set?: TodoListWhereUniqueInput[] | TodoListWhereUniqueInput;
  disconnect?: TodoListWhereUniqueInput[] | TodoListWhereUniqueInput;
  update?:
    | TodoListUpdateWithWhereUniqueWithoutOwnedByInput[]
    | TodoListUpdateWithWhereUniqueWithoutOwnedByInput;
  upsert?:
    | TodoListUpsertWithWhereUniqueWithoutOwnedByInput[]
    | TodoListUpsertWithWhereUniqueWithoutOwnedByInput;
  deleteMany?: TodoListScalarWhereInput[] | TodoListScalarWhereInput;
  updateMany?:
    | TodoListUpdateManyWithWhereNestedInput[]
    | TodoListUpdateManyWithWhereNestedInput;
}

export interface TodoListUpdateWithWhereUniqueWithoutOwnedByInput {
  where: TodoListWhereUniqueInput;
  data: TodoListUpdateWithoutOwnedByDataInput;
}

export interface TodoListUpdateWithoutOwnedByDataInput {
  description?: String;
  assignedTo?: UserUpdateManyWithoutTodoListsAssignedInput;
  todos?: TodoUpdateManyWithoutPartOfInput;
  completed?: Boolean;
  inTeam?: TeamUpdateOneWithoutTodoListsInput;
}

export interface UserUpdateManyWithoutTodoListsAssignedInput {
  create?:
    | UserCreateWithoutTodoListsAssignedInput[]
    | UserCreateWithoutTodoListsAssignedInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutTodoListsAssignedInput[]
    | UserUpdateWithWhereUniqueWithoutTodoListsAssignedInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutTodoListsAssignedInput[]
    | UserUpsertWithWhereUniqueWithoutTodoListsAssignedInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithWhereUniqueWithoutTodoListsAssignedInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutTodoListsAssignedDataInput;
}

export interface UserUpdateWithoutTodoListsAssignedDataInput {
  authId?: String;
  name?: String;
  todoListsOwned?: TodoListUpdateManyWithoutOwnedByInput;
  inTeam?: TeamUpdateManyWithoutMembersInput;
}

export interface TeamUpdateManyWithoutMembersInput {
  create?: TeamCreateWithoutMembersInput[] | TeamCreateWithoutMembersInput;
  delete?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
  connect?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
  set?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
  disconnect?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
  update?:
    | TeamUpdateWithWhereUniqueWithoutMembersInput[]
    | TeamUpdateWithWhereUniqueWithoutMembersInput;
  upsert?:
    | TeamUpsertWithWhereUniqueWithoutMembersInput[]
    | TeamUpsertWithWhereUniqueWithoutMembersInput;
  deleteMany?: TeamScalarWhereInput[] | TeamScalarWhereInput;
  updateMany?:
    | TeamUpdateManyWithWhereNestedInput[]
    | TeamUpdateManyWithWhereNestedInput;
}

export interface TeamUpdateWithWhereUniqueWithoutMembersInput {
  where: TeamWhereUniqueInput;
  data: TeamUpdateWithoutMembersDataInput;
}

export interface TeamUpdateWithoutMembersDataInput {
  teamName?: String;
  todoLists?: TodoListUpdateManyWithoutInTeamInput;
  messages?: MessageUpdateManyWithoutInTeamInput;
  events?: EventUpdateManyWithoutTeamInput;
  tags?: TagUpdateManyWithoutTeamInput;
  documents?: DocumentUpdateManyWithoutTeamInput;
  folders?: FolderUpdateManyWithoutTeamInput;
}

export interface TodoListUpdateManyWithoutInTeamInput {
  create?:
    | TodoListCreateWithoutInTeamInput[]
    | TodoListCreateWithoutInTeamInput;
  delete?: TodoListWhereUniqueInput[] | TodoListWhereUniqueInput;
  connect?: TodoListWhereUniqueInput[] | TodoListWhereUniqueInput;
  set?: TodoListWhereUniqueInput[] | TodoListWhereUniqueInput;
  disconnect?: TodoListWhereUniqueInput[] | TodoListWhereUniqueInput;
  update?:
    | TodoListUpdateWithWhereUniqueWithoutInTeamInput[]
    | TodoListUpdateWithWhereUniqueWithoutInTeamInput;
  upsert?:
    | TodoListUpsertWithWhereUniqueWithoutInTeamInput[]
    | TodoListUpsertWithWhereUniqueWithoutInTeamInput;
  deleteMany?: TodoListScalarWhereInput[] | TodoListScalarWhereInput;
  updateMany?:
    | TodoListUpdateManyWithWhereNestedInput[]
    | TodoListUpdateManyWithWhereNestedInput;
}

export interface TodoListUpdateWithWhereUniqueWithoutInTeamInput {
  where: TodoListWhereUniqueInput;
  data: TodoListUpdateWithoutInTeamDataInput;
}

export interface TodoListUpdateWithoutInTeamDataInput {
  description?: String;
  ownedBy?: UserUpdateManyWithoutTodoListsOwnedInput;
  assignedTo?: UserUpdateManyWithoutTodoListsAssignedInput;
  todos?: TodoUpdateManyWithoutPartOfInput;
  completed?: Boolean;
}

export interface UserUpdateManyWithoutTodoListsOwnedInput {
  create?:
    | UserCreateWithoutTodoListsOwnedInput[]
    | UserCreateWithoutTodoListsOwnedInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutTodoListsOwnedInput[]
    | UserUpdateWithWhereUniqueWithoutTodoListsOwnedInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutTodoListsOwnedInput[]
    | UserUpsertWithWhereUniqueWithoutTodoListsOwnedInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithWhereUniqueWithoutTodoListsOwnedInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutTodoListsOwnedDataInput;
}

export interface UserUpdateWithoutTodoListsOwnedDataInput {
  authId?: String;
  name?: String;
  todoListsAssigned?: TodoListUpdateManyWithoutAssignedToInput;
  inTeam?: TeamUpdateManyWithoutMembersInput;
}

export interface TodoListUpdateManyWithoutAssignedToInput {
  create?:
    | TodoListCreateWithoutAssignedToInput[]
    | TodoListCreateWithoutAssignedToInput;
  delete?: TodoListWhereUniqueInput[] | TodoListWhereUniqueInput;
  connect?: TodoListWhereUniqueInput[] | TodoListWhereUniqueInput;
  set?: TodoListWhereUniqueInput[] | TodoListWhereUniqueInput;
  disconnect?: TodoListWhereUniqueInput[] | TodoListWhereUniqueInput;
  update?:
    | TodoListUpdateWithWhereUniqueWithoutAssignedToInput[]
    | TodoListUpdateWithWhereUniqueWithoutAssignedToInput;
  upsert?:
    | TodoListUpsertWithWhereUniqueWithoutAssignedToInput[]
    | TodoListUpsertWithWhereUniqueWithoutAssignedToInput;
  deleteMany?: TodoListScalarWhereInput[] | TodoListScalarWhereInput;
  updateMany?:
    | TodoListUpdateManyWithWhereNestedInput[]
    | TodoListUpdateManyWithWhereNestedInput;
}

export interface TodoListUpdateWithWhereUniqueWithoutAssignedToInput {
  where: TodoListWhereUniqueInput;
  data: TodoListUpdateWithoutAssignedToDataInput;
}

export interface TodoListUpdateWithoutAssignedToDataInput {
  description?: String;
  ownedBy?: UserUpdateManyWithoutTodoListsOwnedInput;
  todos?: TodoUpdateManyWithoutPartOfInput;
  completed?: Boolean;
  inTeam?: TeamUpdateOneWithoutTodoListsInput;
}

export interface TodoUpdateManyWithoutPartOfInput {
  create?: TodoCreateWithoutPartOfInput[] | TodoCreateWithoutPartOfInput;
  delete?: TodoWhereUniqueInput[] | TodoWhereUniqueInput;
  connect?: TodoWhereUniqueInput[] | TodoWhereUniqueInput;
  set?: TodoWhereUniqueInput[] | TodoWhereUniqueInput;
  disconnect?: TodoWhereUniqueInput[] | TodoWhereUniqueInput;
  update?:
    | TodoUpdateWithWhereUniqueWithoutPartOfInput[]
    | TodoUpdateWithWhereUniqueWithoutPartOfInput;
  upsert?:
    | TodoUpsertWithWhereUniqueWithoutPartOfInput[]
    | TodoUpsertWithWhereUniqueWithoutPartOfInput;
  deleteMany?: TodoScalarWhereInput[] | TodoScalarWhereInput;
  updateMany?:
    | TodoUpdateManyWithWhereNestedInput[]
    | TodoUpdateManyWithWhereNestedInput;
}

export interface TodoUpdateWithWhereUniqueWithoutPartOfInput {
  where: TodoWhereUniqueInput;
  data: TodoUpdateWithoutPartOfDataInput;
}

export interface TodoUpdateWithoutPartOfDataInput {
  description?: String;
  completed?: Boolean;
}

export interface TodoUpsertWithWhereUniqueWithoutPartOfInput {
  where: TodoWhereUniqueInput;
  update: TodoUpdateWithoutPartOfDataInput;
  create: TodoCreateWithoutPartOfInput;
}

export interface TodoScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  completed?: Boolean;
  completed_not?: Boolean;
  AND?: TodoScalarWhereInput[] | TodoScalarWhereInput;
  OR?: TodoScalarWhereInput[] | TodoScalarWhereInput;
  NOT?: TodoScalarWhereInput[] | TodoScalarWhereInput;
}

export interface TodoUpdateManyWithWhereNestedInput {
  where: TodoScalarWhereInput;
  data: TodoUpdateManyDataInput;
}

export interface TodoUpdateManyDataInput {
  description?: String;
  completed?: Boolean;
}

export interface TeamUpdateOneWithoutTodoListsInput {
  create?: TeamCreateWithoutTodoListsInput;
  update?: TeamUpdateWithoutTodoListsDataInput;
  upsert?: TeamUpsertWithoutTodoListsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: TeamWhereUniqueInput;
}

export interface TeamUpdateWithoutTodoListsDataInput {
  teamName?: String;
  members?: UserUpdateManyWithoutInTeamInput;
  messages?: MessageUpdateManyWithoutInTeamInput;
  events?: EventUpdateManyWithoutTeamInput;
  tags?: TagUpdateManyWithoutTeamInput;
  documents?: DocumentUpdateManyWithoutTeamInput;
  folders?: FolderUpdateManyWithoutTeamInput;
}

export interface UserUpdateManyWithoutInTeamInput {
  create?: UserCreateWithoutInTeamInput[] | UserCreateWithoutInTeamInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutInTeamInput[]
    | UserUpdateWithWhereUniqueWithoutInTeamInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutInTeamInput[]
    | UserUpsertWithWhereUniqueWithoutInTeamInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithWhereUniqueWithoutInTeamInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutInTeamDataInput;
}

export interface UserUpdateWithoutInTeamDataInput {
  authId?: String;
  name?: String;
  todoListsOwned?: TodoListUpdateManyWithoutOwnedByInput;
  todoListsAssigned?: TodoListUpdateManyWithoutAssignedToInput;
}

export interface UserUpsertWithWhereUniqueWithoutInTeamInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutInTeamDataInput;
  create: UserCreateWithoutInTeamInput;
}

export interface UserScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  authId?: String;
  authId_not?: String;
  authId_in?: String[] | String;
  authId_not_in?: String[] | String;
  authId_lt?: String;
  authId_lte?: String;
  authId_gt?: String;
  authId_gte?: String;
  authId_contains?: String;
  authId_not_contains?: String;
  authId_starts_with?: String;
  authId_not_starts_with?: String;
  authId_ends_with?: String;
  authId_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: UserScalarWhereInput[] | UserScalarWhereInput;
  OR?: UserScalarWhereInput[] | UserScalarWhereInput;
  NOT?: UserScalarWhereInput[] | UserScalarWhereInput;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface UserUpdateManyDataInput {
  authId?: String;
  name?: String;
}

export interface MessageUpdateManyWithoutInTeamInput {
  create?: MessageCreateWithoutInTeamInput[] | MessageCreateWithoutInTeamInput;
  delete?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  connect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  set?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  disconnect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  update?:
    | MessageUpdateWithWhereUniqueWithoutInTeamInput[]
    | MessageUpdateWithWhereUniqueWithoutInTeamInput;
  upsert?:
    | MessageUpsertWithWhereUniqueWithoutInTeamInput[]
    | MessageUpsertWithWhereUniqueWithoutInTeamInput;
  deleteMany?: MessageScalarWhereInput[] | MessageScalarWhereInput;
  updateMany?:
    | MessageUpdateManyWithWhereNestedInput[]
    | MessageUpdateManyWithWhereNestedInput;
}

export interface MessageUpdateWithWhereUniqueWithoutInTeamInput {
  where: MessageWhereUniqueInput;
  data: MessageUpdateWithoutInTeamDataInput;
}

export interface MessageUpdateWithoutInTeamDataInput {
  title?: String;
  creator?: UserUpdateOneRequiredInput;
  content?: String;
  images?: MessageUpdateimagesInput;
  tag?: TagUpdateOneInput;
  comments?: MessageCommentUpdateManyWithoutMessageInput;
  subscribedUsers?: UserUpdateManyInput;
}

export interface MessageUpdateimagesInput {
  set?: String[] | String;
}

export interface TagUpdateOneInput {
  create?: TagCreateInput;
  update?: TagUpdateDataInput;
  upsert?: TagUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: TagWhereUniqueInput;
}

export interface TagUpdateDataInput {
  name?: String;
  team?: TeamUpdateOneWithoutTagsInput;
}

export interface TeamUpdateOneWithoutTagsInput {
  create?: TeamCreateWithoutTagsInput;
  update?: TeamUpdateWithoutTagsDataInput;
  upsert?: TeamUpsertWithoutTagsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: TeamWhereUniqueInput;
}

export interface TeamUpdateWithoutTagsDataInput {
  teamName?: String;
  members?: UserUpdateManyWithoutInTeamInput;
  todoLists?: TodoListUpdateManyWithoutInTeamInput;
  messages?: MessageUpdateManyWithoutInTeamInput;
  events?: EventUpdateManyWithoutTeamInput;
  documents?: DocumentUpdateManyWithoutTeamInput;
  folders?: FolderUpdateManyWithoutTeamInput;
}

export interface EventUpdateManyWithoutTeamInput {
  create?: EventCreateWithoutTeamInput[] | EventCreateWithoutTeamInput;
  delete?: EventWhereUniqueInput[] | EventWhereUniqueInput;
  connect?: EventWhereUniqueInput[] | EventWhereUniqueInput;
  set?: EventWhereUniqueInput[] | EventWhereUniqueInput;
  disconnect?: EventWhereUniqueInput[] | EventWhereUniqueInput;
  update?:
    | EventUpdateWithWhereUniqueWithoutTeamInput[]
    | EventUpdateWithWhereUniqueWithoutTeamInput;
  upsert?:
    | EventUpsertWithWhereUniqueWithoutTeamInput[]
    | EventUpsertWithWhereUniqueWithoutTeamInput;
  deleteMany?: EventScalarWhereInput[] | EventScalarWhereInput;
  updateMany?:
    | EventUpdateManyWithWhereNestedInput[]
    | EventUpdateManyWithWhereNestedInput;
}

export interface EventUpdateWithWhereUniqueWithoutTeamInput {
  where: EventWhereUniqueInput;
  data: EventUpdateWithoutTeamDataInput;
}

export interface EventUpdateWithoutTeamDataInput {
  user?: UserUpdateOneInput;
  action_string?: String;
  object_string?: String;
}

export interface UserUpdateOneInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface EventUpsertWithWhereUniqueWithoutTeamInput {
  where: EventWhereUniqueInput;
  update: EventUpdateWithoutTeamDataInput;
  create: EventCreateWithoutTeamInput;
}

export interface EventScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  action_string?: String;
  action_string_not?: String;
  action_string_in?: String[] | String;
  action_string_not_in?: String[] | String;
  action_string_lt?: String;
  action_string_lte?: String;
  action_string_gt?: String;
  action_string_gte?: String;
  action_string_contains?: String;
  action_string_not_contains?: String;
  action_string_starts_with?: String;
  action_string_not_starts_with?: String;
  action_string_ends_with?: String;
  action_string_not_ends_with?: String;
  object_string?: String;
  object_string_not?: String;
  object_string_in?: String[] | String;
  object_string_not_in?: String[] | String;
  object_string_lt?: String;
  object_string_lte?: String;
  object_string_gt?: String;
  object_string_gte?: String;
  object_string_contains?: String;
  object_string_not_contains?: String;
  object_string_starts_with?: String;
  object_string_not_starts_with?: String;
  object_string_ends_with?: String;
  object_string_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: EventScalarWhereInput[] | EventScalarWhereInput;
  OR?: EventScalarWhereInput[] | EventScalarWhereInput;
  NOT?: EventScalarWhereInput[] | EventScalarWhereInput;
}

export interface EventUpdateManyWithWhereNestedInput {
  where: EventScalarWhereInput;
  data: EventUpdateManyDataInput;
}

export interface EventUpdateManyDataInput {
  action_string?: String;
  object_string?: String;
}

export interface DocumentUpdateManyWithoutTeamInput {
  create?: DocumentCreateWithoutTeamInput[] | DocumentCreateWithoutTeamInput;
  delete?: DocumentWhereUniqueInput[] | DocumentWhereUniqueInput;
  connect?: DocumentWhereUniqueInput[] | DocumentWhereUniqueInput;
  set?: DocumentWhereUniqueInput[] | DocumentWhereUniqueInput;
  disconnect?: DocumentWhereUniqueInput[] | DocumentWhereUniqueInput;
  update?:
    | DocumentUpdateWithWhereUniqueWithoutTeamInput[]
    | DocumentUpdateWithWhereUniqueWithoutTeamInput;
  upsert?:
    | DocumentUpsertWithWhereUniqueWithoutTeamInput[]
    | DocumentUpsertWithWhereUniqueWithoutTeamInput;
  deleteMany?: DocumentScalarWhereInput[] | DocumentScalarWhereInput;
  updateMany?:
    | DocumentUpdateManyWithWhereNestedInput[]
    | DocumentUpdateManyWithWhereNestedInput;
}

export interface DocumentUpdateWithWhereUniqueWithoutTeamInput {
  where: DocumentWhereUniqueInput;
  data: DocumentUpdateWithoutTeamDataInput;
}

export interface DocumentUpdateWithoutTeamDataInput {
  doc_url?: String;
  user?: UserUpdateOneRequiredInput;
  folder?: FolderUpdateOneWithoutDocumentsInput;
  title?: String;
  textContent?: String;
  tag?: TagUpdateOneInput;
  images?: DocumentUpdateimagesInput;
  comments?: DocumentCommentUpdateManyWithoutDocumentInput;
  subscribedUsers?: UserUpdateManyInput;
}

export interface FolderUpdateOneWithoutDocumentsInput {
  create?: FolderCreateWithoutDocumentsInput;
  update?: FolderUpdateWithoutDocumentsDataInput;
  upsert?: FolderUpsertWithoutDocumentsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: FolderWhereUniqueInput;
}

export interface FolderUpdateWithoutDocumentsDataInput {
  title?: String;
  user?: UserUpdateOneRequiredInput;
  team?: TeamUpdateOneRequiredWithoutFoldersInput;
}

export interface TeamUpdateOneRequiredWithoutFoldersInput {
  create?: TeamCreateWithoutFoldersInput;
  update?: TeamUpdateWithoutFoldersDataInput;
  upsert?: TeamUpsertWithoutFoldersInput;
  connect?: TeamWhereUniqueInput;
}

export interface TeamUpdateWithoutFoldersDataInput {
  teamName?: String;
  members?: UserUpdateManyWithoutInTeamInput;
  todoLists?: TodoListUpdateManyWithoutInTeamInput;
  messages?: MessageUpdateManyWithoutInTeamInput;
  events?: EventUpdateManyWithoutTeamInput;
  tags?: TagUpdateManyWithoutTeamInput;
  documents?: DocumentUpdateManyWithoutTeamInput;
}

export interface TagUpdateManyWithoutTeamInput {
  create?: TagCreateWithoutTeamInput[] | TagCreateWithoutTeamInput;
  delete?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  connect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  set?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  disconnect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  update?:
    | TagUpdateWithWhereUniqueWithoutTeamInput[]
    | TagUpdateWithWhereUniqueWithoutTeamInput;
  upsert?:
    | TagUpsertWithWhereUniqueWithoutTeamInput[]
    | TagUpsertWithWhereUniqueWithoutTeamInput;
  deleteMany?: TagScalarWhereInput[] | TagScalarWhereInput;
  updateMany?:
    | TagUpdateManyWithWhereNestedInput[]
    | TagUpdateManyWithWhereNestedInput;
}

export interface TagUpdateWithWhereUniqueWithoutTeamInput {
  where: TagWhereUniqueInput;
  data: TagUpdateWithoutTeamDataInput;
}

export interface TagUpdateWithoutTeamDataInput {
  name?: String;
}

export interface TagUpsertWithWhereUniqueWithoutTeamInput {
  where: TagWhereUniqueInput;
  update: TagUpdateWithoutTeamDataInput;
  create: TagCreateWithoutTeamInput;
}

export interface TagScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: TagScalarWhereInput[] | TagScalarWhereInput;
  OR?: TagScalarWhereInput[] | TagScalarWhereInput;
  NOT?: TagScalarWhereInput[] | TagScalarWhereInput;
}

export interface TagUpdateManyWithWhereNestedInput {
  where: TagScalarWhereInput;
  data: TagUpdateManyDataInput;
}

export interface TagUpdateManyDataInput {
  name?: String;
}

export interface TeamUpsertWithoutFoldersInput {
  update: TeamUpdateWithoutFoldersDataInput;
  create: TeamCreateWithoutFoldersInput;
}

export interface FolderUpsertWithoutDocumentsInput {
  update: FolderUpdateWithoutDocumentsDataInput;
  create: FolderCreateWithoutDocumentsInput;
}

export interface DocumentUpdateimagesInput {
  set?: String[] | String;
}

export interface DocumentCommentUpdateManyWithoutDocumentInput {
  create?:
    | DocumentCommentCreateWithoutDocumentInput[]
    | DocumentCommentCreateWithoutDocumentInput;
  delete?: DocumentCommentWhereUniqueInput[] | DocumentCommentWhereUniqueInput;
  connect?: DocumentCommentWhereUniqueInput[] | DocumentCommentWhereUniqueInput;
  set?: DocumentCommentWhereUniqueInput[] | DocumentCommentWhereUniqueInput;
  disconnect?:
    | DocumentCommentWhereUniqueInput[]
    | DocumentCommentWhereUniqueInput;
  update?:
    | DocumentCommentUpdateWithWhereUniqueWithoutDocumentInput[]
    | DocumentCommentUpdateWithWhereUniqueWithoutDocumentInput;
  upsert?:
    | DocumentCommentUpsertWithWhereUniqueWithoutDocumentInput[]
    | DocumentCommentUpsertWithWhereUniqueWithoutDocumentInput;
  deleteMany?:
    | DocumentCommentScalarWhereInput[]
    | DocumentCommentScalarWhereInput;
  updateMany?:
    | DocumentCommentUpdateManyWithWhereNestedInput[]
    | DocumentCommentUpdateManyWithWhereNestedInput;
}

export interface DocumentCommentUpdateWithWhereUniqueWithoutDocumentInput {
  where: DocumentCommentWhereUniqueInput;
  data: DocumentCommentUpdateWithoutDocumentDataInput;
}

export interface DocumentCommentUpdateWithoutDocumentDataInput {
  user?: UserUpdateOneRequiredInput;
  content?: String;
  image?: String;
  likes?: UserUpdateManyInput;
}

export interface UserUpdateManyInput {
  create?: UserCreateInput[] | UserCreateInput;
  update?:
    | UserUpdateWithWhereUniqueNestedInput[]
    | UserUpdateWithWhereUniqueNestedInput;
  upsert?:
    | UserUpsertWithWhereUniqueNestedInput[]
    | UserUpsertWithWhereUniqueNestedInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  data: UserUpdateDataInput;
}

export interface UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface DocumentCommentUpsertWithWhereUniqueWithoutDocumentInput {
  where: DocumentCommentWhereUniqueInput;
  update: DocumentCommentUpdateWithoutDocumentDataInput;
  create: DocumentCommentCreateWithoutDocumentInput;
}

export interface DocumentCommentScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  image?: String;
  image_not?: String;
  image_in?: String[] | String;
  image_not_in?: String[] | String;
  image_lt?: String;
  image_lte?: String;
  image_gt?: String;
  image_gte?: String;
  image_contains?: String;
  image_not_contains?: String;
  image_starts_with?: String;
  image_not_starts_with?: String;
  image_ends_with?: String;
  image_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: DocumentCommentScalarWhereInput[] | DocumentCommentScalarWhereInput;
  OR?: DocumentCommentScalarWhereInput[] | DocumentCommentScalarWhereInput;
  NOT?: DocumentCommentScalarWhereInput[] | DocumentCommentScalarWhereInput;
}

export interface DocumentCommentUpdateManyWithWhereNestedInput {
  where: DocumentCommentScalarWhereInput;
  data: DocumentCommentUpdateManyDataInput;
}

export interface DocumentCommentUpdateManyDataInput {
  content?: String;
  image?: String;
}

export interface DocumentUpsertWithWhereUniqueWithoutTeamInput {
  where: DocumentWhereUniqueInput;
  update: DocumentUpdateWithoutTeamDataInput;
  create: DocumentCreateWithoutTeamInput;
}

export interface DocumentScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  doc_url?: String;
  doc_url_not?: String;
  doc_url_in?: String[] | String;
  doc_url_not_in?: String[] | String;
  doc_url_lt?: String;
  doc_url_lte?: String;
  doc_url_gt?: String;
  doc_url_gte?: String;
  doc_url_contains?: String;
  doc_url_not_contains?: String;
  doc_url_starts_with?: String;
  doc_url_not_starts_with?: String;
  doc_url_ends_with?: String;
  doc_url_not_ends_with?: String;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  textContent?: String;
  textContent_not?: String;
  textContent_in?: String[] | String;
  textContent_not_in?: String[] | String;
  textContent_lt?: String;
  textContent_lte?: String;
  textContent_gt?: String;
  textContent_gte?: String;
  textContent_contains?: String;
  textContent_not_contains?: String;
  textContent_starts_with?: String;
  textContent_not_starts_with?: String;
  textContent_ends_with?: String;
  textContent_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: DocumentScalarWhereInput[] | DocumentScalarWhereInput;
  OR?: DocumentScalarWhereInput[] | DocumentScalarWhereInput;
  NOT?: DocumentScalarWhereInput[] | DocumentScalarWhereInput;
}

export interface DocumentUpdateManyWithWhereNestedInput {
  where: DocumentScalarWhereInput;
  data: DocumentUpdateManyDataInput;
}

export interface DocumentUpdateManyDataInput {
  doc_url?: String;
  title?: String;
  textContent?: String;
  images?: DocumentUpdateimagesInput;
}

export interface FolderUpdateManyWithoutTeamInput {
  create?: FolderCreateWithoutTeamInput[] | FolderCreateWithoutTeamInput;
  delete?: FolderWhereUniqueInput[] | FolderWhereUniqueInput;
  connect?: FolderWhereUniqueInput[] | FolderWhereUniqueInput;
  set?: FolderWhereUniqueInput[] | FolderWhereUniqueInput;
  disconnect?: FolderWhereUniqueInput[] | FolderWhereUniqueInput;
  update?:
    | FolderUpdateWithWhereUniqueWithoutTeamInput[]
    | FolderUpdateWithWhereUniqueWithoutTeamInput;
  upsert?:
    | FolderUpsertWithWhereUniqueWithoutTeamInput[]
    | FolderUpsertWithWhereUniqueWithoutTeamInput;
  deleteMany?: FolderScalarWhereInput[] | FolderScalarWhereInput;
  updateMany?:
    | FolderUpdateManyWithWhereNestedInput[]
    | FolderUpdateManyWithWhereNestedInput;
}

export interface FolderUpdateWithWhereUniqueWithoutTeamInput {
  where: FolderWhereUniqueInput;
  data: FolderUpdateWithoutTeamDataInput;
}

export interface FolderUpdateWithoutTeamDataInput {
  title?: String;
  user?: UserUpdateOneRequiredInput;
  documents?: DocumentUpdateManyWithoutFolderInput;
}

export interface DocumentUpdateManyWithoutFolderInput {
  create?:
    | DocumentCreateWithoutFolderInput[]
    | DocumentCreateWithoutFolderInput;
  delete?: DocumentWhereUniqueInput[] | DocumentWhereUniqueInput;
  connect?: DocumentWhereUniqueInput[] | DocumentWhereUniqueInput;
  set?: DocumentWhereUniqueInput[] | DocumentWhereUniqueInput;
  disconnect?: DocumentWhereUniqueInput[] | DocumentWhereUniqueInput;
  update?:
    | DocumentUpdateWithWhereUniqueWithoutFolderInput[]
    | DocumentUpdateWithWhereUniqueWithoutFolderInput;
  upsert?:
    | DocumentUpsertWithWhereUniqueWithoutFolderInput[]
    | DocumentUpsertWithWhereUniqueWithoutFolderInput;
  deleteMany?: DocumentScalarWhereInput[] | DocumentScalarWhereInput;
  updateMany?:
    | DocumentUpdateManyWithWhereNestedInput[]
    | DocumentUpdateManyWithWhereNestedInput;
}

export interface DocumentUpdateWithWhereUniqueWithoutFolderInput {
  where: DocumentWhereUniqueInput;
  data: DocumentUpdateWithoutFolderDataInput;
}

export interface DocumentUpdateWithoutFolderDataInput {
  doc_url?: String;
  user?: UserUpdateOneRequiredInput;
  team?: TeamUpdateOneRequiredWithoutDocumentsInput;
  title?: String;
  textContent?: String;
  tag?: TagUpdateOneInput;
  images?: DocumentUpdateimagesInput;
  comments?: DocumentCommentUpdateManyWithoutDocumentInput;
  subscribedUsers?: UserUpdateManyInput;
}

export interface TeamUpdateOneRequiredWithoutDocumentsInput {
  create?: TeamCreateWithoutDocumentsInput;
  update?: TeamUpdateWithoutDocumentsDataInput;
  upsert?: TeamUpsertWithoutDocumentsInput;
  connect?: TeamWhereUniqueInput;
}

export interface TeamUpdateWithoutDocumentsDataInput {
  teamName?: String;
  members?: UserUpdateManyWithoutInTeamInput;
  todoLists?: TodoListUpdateManyWithoutInTeamInput;
  messages?: MessageUpdateManyWithoutInTeamInput;
  events?: EventUpdateManyWithoutTeamInput;
  tags?: TagUpdateManyWithoutTeamInput;
  folders?: FolderUpdateManyWithoutTeamInput;
}

export interface TeamUpsertWithoutDocumentsInput {
  update: TeamUpdateWithoutDocumentsDataInput;
  create: TeamCreateWithoutDocumentsInput;
}

export interface DocumentUpsertWithWhereUniqueWithoutFolderInput {
  where: DocumentWhereUniqueInput;
  update: DocumentUpdateWithoutFolderDataInput;
  create: DocumentCreateWithoutFolderInput;
}

export interface FolderUpsertWithWhereUniqueWithoutTeamInput {
  where: FolderWhereUniqueInput;
  update: FolderUpdateWithoutTeamDataInput;
  create: FolderCreateWithoutTeamInput;
}

export interface FolderScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: FolderScalarWhereInput[] | FolderScalarWhereInput;
  OR?: FolderScalarWhereInput[] | FolderScalarWhereInput;
  NOT?: FolderScalarWhereInput[] | FolderScalarWhereInput;
}

export interface FolderUpdateManyWithWhereNestedInput {
  where: FolderScalarWhereInput;
  data: FolderUpdateManyDataInput;
}

export interface FolderUpdateManyDataInput {
  title?: String;
}

export interface TeamUpsertWithoutTagsInput {
  update: TeamUpdateWithoutTagsDataInput;
  create: TeamCreateWithoutTagsInput;
}

export interface TagUpsertNestedInput {
  update: TagUpdateDataInput;
  create: TagCreateInput;
}

export interface MessageCommentUpdateManyWithoutMessageInput {
  create?:
    | MessageCommentCreateWithoutMessageInput[]
    | MessageCommentCreateWithoutMessageInput;
  delete?: MessageCommentWhereUniqueInput[] | MessageCommentWhereUniqueInput;
  connect?: MessageCommentWhereUniqueInput[] | MessageCommentWhereUniqueInput;
  set?: MessageCommentWhereUniqueInput[] | MessageCommentWhereUniqueInput;
  disconnect?:
    | MessageCommentWhereUniqueInput[]
    | MessageCommentWhereUniqueInput;
  update?:
    | MessageCommentUpdateWithWhereUniqueWithoutMessageInput[]
    | MessageCommentUpdateWithWhereUniqueWithoutMessageInput;
  upsert?:
    | MessageCommentUpsertWithWhereUniqueWithoutMessageInput[]
    | MessageCommentUpsertWithWhereUniqueWithoutMessageInput;
  deleteMany?:
    | MessageCommentScalarWhereInput[]
    | MessageCommentScalarWhereInput;
  updateMany?:
    | MessageCommentUpdateManyWithWhereNestedInput[]
    | MessageCommentUpdateManyWithWhereNestedInput;
}

export interface MessageCommentUpdateWithWhereUniqueWithoutMessageInput {
  where: MessageCommentWhereUniqueInput;
  data: MessageCommentUpdateWithoutMessageDataInput;
}

export interface MessageCommentUpdateWithoutMessageDataInput {
  content?: String;
  user?: UserUpdateOneRequiredInput;
  image?: String;
  likes?: UserUpdateManyInput;
}

export interface MessageCommentUpsertWithWhereUniqueWithoutMessageInput {
  where: MessageCommentWhereUniqueInput;
  update: MessageCommentUpdateWithoutMessageDataInput;
  create: MessageCommentCreateWithoutMessageInput;
}

export interface MessageCommentScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  image?: String;
  image_not?: String;
  image_in?: String[] | String;
  image_not_in?: String[] | String;
  image_lt?: String;
  image_lte?: String;
  image_gt?: String;
  image_gte?: String;
  image_contains?: String;
  image_not_contains?: String;
  image_starts_with?: String;
  image_not_starts_with?: String;
  image_ends_with?: String;
  image_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: MessageCommentScalarWhereInput[] | MessageCommentScalarWhereInput;
  OR?: MessageCommentScalarWhereInput[] | MessageCommentScalarWhereInput;
  NOT?: MessageCommentScalarWhereInput[] | MessageCommentScalarWhereInput;
}

export interface MessageCommentUpdateManyWithWhereNestedInput {
  where: MessageCommentScalarWhereInput;
  data: MessageCommentUpdateManyDataInput;
}

export interface MessageCommentUpdateManyDataInput {
  content?: String;
  image?: String;
}

export interface MessageUpsertWithWhereUniqueWithoutInTeamInput {
  where: MessageWhereUniqueInput;
  update: MessageUpdateWithoutInTeamDataInput;
  create: MessageCreateWithoutInTeamInput;
}

export interface MessageScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: MessageScalarWhereInput[] | MessageScalarWhereInput;
  OR?: MessageScalarWhereInput[] | MessageScalarWhereInput;
  NOT?: MessageScalarWhereInput[] | MessageScalarWhereInput;
}

export interface MessageUpdateManyWithWhereNestedInput {
  where: MessageScalarWhereInput;
  data: MessageUpdateManyDataInput;
}

export interface MessageUpdateManyDataInput {
  title?: String;
  content?: String;
  images?: MessageUpdateimagesInput;
}

export interface TeamUpsertWithoutTodoListsInput {
  update: TeamUpdateWithoutTodoListsDataInput;
  create: TeamCreateWithoutTodoListsInput;
}

export interface TodoListUpsertWithWhereUniqueWithoutAssignedToInput {
  where: TodoListWhereUniqueInput;
  update: TodoListUpdateWithoutAssignedToDataInput;
  create: TodoListCreateWithoutAssignedToInput;
}

export interface TodoListScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  completed?: Boolean;
  completed_not?: Boolean;
  AND?: TodoListScalarWhereInput[] | TodoListScalarWhereInput;
  OR?: TodoListScalarWhereInput[] | TodoListScalarWhereInput;
  NOT?: TodoListScalarWhereInput[] | TodoListScalarWhereInput;
}

export interface TodoListUpdateManyWithWhereNestedInput {
  where: TodoListScalarWhereInput;
  data: TodoListUpdateManyDataInput;
}

export interface TodoListUpdateManyDataInput {
  description?: String;
  completed?: Boolean;
}

export interface UserUpsertWithWhereUniqueWithoutTodoListsOwnedInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutTodoListsOwnedDataInput;
  create: UserCreateWithoutTodoListsOwnedInput;
}

export interface TodoListUpsertWithWhereUniqueWithoutInTeamInput {
  where: TodoListWhereUniqueInput;
  update: TodoListUpdateWithoutInTeamDataInput;
  create: TodoListCreateWithoutInTeamInput;
}

export interface TeamUpsertWithWhereUniqueWithoutMembersInput {
  where: TeamWhereUniqueInput;
  update: TeamUpdateWithoutMembersDataInput;
  create: TeamCreateWithoutMembersInput;
}

export interface TeamScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  teamName?: String;
  teamName_not?: String;
  teamName_in?: String[] | String;
  teamName_not_in?: String[] | String;
  teamName_lt?: String;
  teamName_lte?: String;
  teamName_gt?: String;
  teamName_gte?: String;
  teamName_contains?: String;
  teamName_not_contains?: String;
  teamName_starts_with?: String;
  teamName_not_starts_with?: String;
  teamName_ends_with?: String;
  teamName_not_ends_with?: String;
  AND?: TeamScalarWhereInput[] | TeamScalarWhereInput;
  OR?: TeamScalarWhereInput[] | TeamScalarWhereInput;
  NOT?: TeamScalarWhereInput[] | TeamScalarWhereInput;
}

export interface TeamUpdateManyWithWhereNestedInput {
  where: TeamScalarWhereInput;
  data: TeamUpdateManyDataInput;
}

export interface TeamUpdateManyDataInput {
  teamName?: String;
}

export interface UserUpsertWithWhereUniqueWithoutTodoListsAssignedInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutTodoListsAssignedDataInput;
  create: UserCreateWithoutTodoListsAssignedInput;
}

export interface TodoListUpsertWithWhereUniqueWithoutOwnedByInput {
  where: TodoListWhereUniqueInput;
  update: TodoListUpdateWithoutOwnedByDataInput;
  create: TodoListCreateWithoutOwnedByInput;
}

export interface DocumentUpdateManyMutationInput {
  doc_url?: String;
  title?: String;
  textContent?: String;
  images?: DocumentUpdateimagesInput;
}

export interface DocumentCommentCreateInput {
  user: UserCreateOneInput;
  document: DocumentCreateOneWithoutCommentsInput;
  content: String;
  image?: String;
  likes?: UserCreateManyInput;
}

export interface DocumentCreateOneWithoutCommentsInput {
  create?: DocumentCreateWithoutCommentsInput;
  connect?: DocumentWhereUniqueInput;
}

export interface DocumentCreateWithoutCommentsInput {
  doc_url: String;
  user: UserCreateOneInput;
  folder?: FolderCreateOneWithoutDocumentsInput;
  team: TeamCreateOneWithoutDocumentsInput;
  title: String;
  textContent: String;
  tag?: TagCreateOneInput;
  images?: DocumentCreateimagesInput;
  subscribedUsers?: UserCreateManyInput;
}

export interface DocumentCommentUpdateInput {
  user?: UserUpdateOneRequiredInput;
  document?: DocumentUpdateOneRequiredWithoutCommentsInput;
  content?: String;
  image?: String;
  likes?: UserUpdateManyInput;
}

export interface DocumentUpdateOneRequiredWithoutCommentsInput {
  create?: DocumentCreateWithoutCommentsInput;
  update?: DocumentUpdateWithoutCommentsDataInput;
  upsert?: DocumentUpsertWithoutCommentsInput;
  connect?: DocumentWhereUniqueInput;
}

export interface DocumentUpdateWithoutCommentsDataInput {
  doc_url?: String;
  user?: UserUpdateOneRequiredInput;
  folder?: FolderUpdateOneWithoutDocumentsInput;
  team?: TeamUpdateOneRequiredWithoutDocumentsInput;
  title?: String;
  textContent?: String;
  tag?: TagUpdateOneInput;
  images?: DocumentUpdateimagesInput;
  subscribedUsers?: UserUpdateManyInput;
}

export interface DocumentUpsertWithoutCommentsInput {
  update: DocumentUpdateWithoutCommentsDataInput;
  create: DocumentCreateWithoutCommentsInput;
}

export interface DocumentCommentUpdateManyMutationInput {
  content?: String;
  image?: String;
}

export interface EventCreateInput {
  team: TeamCreateOneWithoutEventsInput;
  user?: UserCreateOneInput;
  action_string: String;
  object_string: String;
}

export interface TeamCreateOneWithoutEventsInput {
  create?: TeamCreateWithoutEventsInput;
  connect?: TeamWhereUniqueInput;
}

export interface TeamCreateWithoutEventsInput {
  teamName: String;
  members?: UserCreateManyWithoutInTeamInput;
  todoLists?: TodoListCreateManyWithoutInTeamInput;
  messages?: MessageCreateManyWithoutInTeamInput;
  tags?: TagCreateManyWithoutTeamInput;
  documents?: DocumentCreateManyWithoutTeamInput;
  folders?: FolderCreateManyWithoutTeamInput;
}

export interface EventUpdateInput {
  team?: TeamUpdateOneRequiredWithoutEventsInput;
  user?: UserUpdateOneInput;
  action_string?: String;
  object_string?: String;
}

export interface TeamUpdateOneRequiredWithoutEventsInput {
  create?: TeamCreateWithoutEventsInput;
  update?: TeamUpdateWithoutEventsDataInput;
  upsert?: TeamUpsertWithoutEventsInput;
  connect?: TeamWhereUniqueInput;
}

export interface TeamUpdateWithoutEventsDataInput {
  teamName?: String;
  members?: UserUpdateManyWithoutInTeamInput;
  todoLists?: TodoListUpdateManyWithoutInTeamInput;
  messages?: MessageUpdateManyWithoutInTeamInput;
  tags?: TagUpdateManyWithoutTeamInput;
  documents?: DocumentUpdateManyWithoutTeamInput;
  folders?: FolderUpdateManyWithoutTeamInput;
}

export interface TeamUpsertWithoutEventsInput {
  update: TeamUpdateWithoutEventsDataInput;
  create: TeamCreateWithoutEventsInput;
}

export interface EventUpdateManyMutationInput {
  action_string?: String;
  object_string?: String;
}

export interface FolderCreateInput {
  title: String;
  user: UserCreateOneInput;
  team: TeamCreateOneWithoutFoldersInput;
  documents?: DocumentCreateManyWithoutFolderInput;
}

export interface FolderUpdateInput {
  title?: String;
  user?: UserUpdateOneRequiredInput;
  team?: TeamUpdateOneRequiredWithoutFoldersInput;
  documents?: DocumentUpdateManyWithoutFolderInput;
}

export interface FolderUpdateManyMutationInput {
  title?: String;
}

export interface MessageCreateInput {
  title: String;
  creator: UserCreateOneInput;
  inTeam: TeamCreateOneWithoutMessagesInput;
  content: String;
  images?: MessageCreateimagesInput;
  tag?: TagCreateOneInput;
  comments?: MessageCommentCreateManyWithoutMessageInput;
  subscribedUsers?: UserCreateManyInput;
}

export interface TeamCreateOneWithoutMessagesInput {
  create?: TeamCreateWithoutMessagesInput;
  connect?: TeamWhereUniqueInput;
}

export interface TeamCreateWithoutMessagesInput {
  teamName: String;
  members?: UserCreateManyWithoutInTeamInput;
  todoLists?: TodoListCreateManyWithoutInTeamInput;
  events?: EventCreateManyWithoutTeamInput;
  tags?: TagCreateManyWithoutTeamInput;
  documents?: DocumentCreateManyWithoutTeamInput;
  folders?: FolderCreateManyWithoutTeamInput;
}

export interface MessageUpdateInput {
  title?: String;
  creator?: UserUpdateOneRequiredInput;
  inTeam?: TeamUpdateOneRequiredWithoutMessagesInput;
  content?: String;
  images?: MessageUpdateimagesInput;
  tag?: TagUpdateOneInput;
  comments?: MessageCommentUpdateManyWithoutMessageInput;
  subscribedUsers?: UserUpdateManyInput;
}

export interface TeamUpdateOneRequiredWithoutMessagesInput {
  create?: TeamCreateWithoutMessagesInput;
  update?: TeamUpdateWithoutMessagesDataInput;
  upsert?: TeamUpsertWithoutMessagesInput;
  connect?: TeamWhereUniqueInput;
}

export interface TeamUpdateWithoutMessagesDataInput {
  teamName?: String;
  members?: UserUpdateManyWithoutInTeamInput;
  todoLists?: TodoListUpdateManyWithoutInTeamInput;
  events?: EventUpdateManyWithoutTeamInput;
  tags?: TagUpdateManyWithoutTeamInput;
  documents?: DocumentUpdateManyWithoutTeamInput;
  folders?: FolderUpdateManyWithoutTeamInput;
}

export interface TeamUpsertWithoutMessagesInput {
  update: TeamUpdateWithoutMessagesDataInput;
  create: TeamCreateWithoutMessagesInput;
}

export interface MessageUpdateManyMutationInput {
  title?: String;
  content?: String;
  images?: MessageUpdateimagesInput;
}

export interface MessageCommentCreateInput {
  content: String;
  user: UserCreateOneInput;
  message: MessageCreateOneWithoutCommentsInput;
  image?: String;
  likes?: UserCreateManyInput;
}

export interface MessageCreateOneWithoutCommentsInput {
  create?: MessageCreateWithoutCommentsInput;
  connect?: MessageWhereUniqueInput;
}

export interface MessageCreateWithoutCommentsInput {
  title: String;
  creator: UserCreateOneInput;
  inTeam: TeamCreateOneWithoutMessagesInput;
  content: String;
  images?: MessageCreateimagesInput;
  tag?: TagCreateOneInput;
  subscribedUsers?: UserCreateManyInput;
}

export interface MessageCommentUpdateInput {
  content?: String;
  user?: UserUpdateOneRequiredInput;
  message?: MessageUpdateOneRequiredWithoutCommentsInput;
  image?: String;
  likes?: UserUpdateManyInput;
}

export interface MessageUpdateOneRequiredWithoutCommentsInput {
  create?: MessageCreateWithoutCommentsInput;
  update?: MessageUpdateWithoutCommentsDataInput;
  upsert?: MessageUpsertWithoutCommentsInput;
  connect?: MessageWhereUniqueInput;
}

export interface MessageUpdateWithoutCommentsDataInput {
  title?: String;
  creator?: UserUpdateOneRequiredInput;
  inTeam?: TeamUpdateOneRequiredWithoutMessagesInput;
  content?: String;
  images?: MessageUpdateimagesInput;
  tag?: TagUpdateOneInput;
  subscribedUsers?: UserUpdateManyInput;
}

export interface MessageUpsertWithoutCommentsInput {
  update: MessageUpdateWithoutCommentsDataInput;
  create: MessageCreateWithoutCommentsInput;
}

export interface MessageCommentUpdateManyMutationInput {
  content?: String;
  image?: String;
}

export interface TagUpdateInput {
  name?: String;
  team?: TeamUpdateOneWithoutTagsInput;
}

export interface TagUpdateManyMutationInput {
  name?: String;
}

export interface TeamCreateInput {
  teamName: String;
  members?: UserCreateManyWithoutInTeamInput;
  todoLists?: TodoListCreateManyWithoutInTeamInput;
  messages?: MessageCreateManyWithoutInTeamInput;
  events?: EventCreateManyWithoutTeamInput;
  tags?: TagCreateManyWithoutTeamInput;
  documents?: DocumentCreateManyWithoutTeamInput;
  folders?: FolderCreateManyWithoutTeamInput;
}

export interface TeamUpdateInput {
  teamName?: String;
  members?: UserUpdateManyWithoutInTeamInput;
  todoLists?: TodoListUpdateManyWithoutInTeamInput;
  messages?: MessageUpdateManyWithoutInTeamInput;
  events?: EventUpdateManyWithoutTeamInput;
  tags?: TagUpdateManyWithoutTeamInput;
  documents?: DocumentUpdateManyWithoutTeamInput;
  folders?: FolderUpdateManyWithoutTeamInput;
}

export interface TeamUpdateManyMutationInput {
  teamName?: String;
}

export interface TodoCreateInput {
  description: String;
  partOf?: TodoListCreateOneWithoutTodosInput;
  completed?: Boolean;
}

export interface TodoListCreateOneWithoutTodosInput {
  create?: TodoListCreateWithoutTodosInput;
  connect?: TodoListWhereUniqueInput;
}

export interface TodoListCreateWithoutTodosInput {
  description: String;
  ownedBy?: UserCreateManyWithoutTodoListsOwnedInput;
  assignedTo?: UserCreateManyWithoutTodoListsAssignedInput;
  completed?: Boolean;
  inTeam?: TeamCreateOneWithoutTodoListsInput;
}

export interface TodoUpdateInput {
  description?: String;
  partOf?: TodoListUpdateOneWithoutTodosInput;
  completed?: Boolean;
}

export interface TodoListUpdateOneWithoutTodosInput {
  create?: TodoListCreateWithoutTodosInput;
  update?: TodoListUpdateWithoutTodosDataInput;
  upsert?: TodoListUpsertWithoutTodosInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: TodoListWhereUniqueInput;
}

export interface TodoListUpdateWithoutTodosDataInput {
  description?: String;
  ownedBy?: UserUpdateManyWithoutTodoListsOwnedInput;
  assignedTo?: UserUpdateManyWithoutTodoListsAssignedInput;
  completed?: Boolean;
  inTeam?: TeamUpdateOneWithoutTodoListsInput;
}

export interface TodoListUpsertWithoutTodosInput {
  update: TodoListUpdateWithoutTodosDataInput;
  create: TodoListCreateWithoutTodosInput;
}

export interface TodoUpdateManyMutationInput {
  description?: String;
  completed?: Boolean;
}

export interface TodoListCreateInput {
  description: String;
  ownedBy?: UserCreateManyWithoutTodoListsOwnedInput;
  assignedTo?: UserCreateManyWithoutTodoListsAssignedInput;
  todos?: TodoCreateManyWithoutPartOfInput;
  completed?: Boolean;
  inTeam?: TeamCreateOneWithoutTodoListsInput;
}

export interface TodoListUpdateInput {
  description?: String;
  ownedBy?: UserUpdateManyWithoutTodoListsOwnedInput;
  assignedTo?: UserUpdateManyWithoutTodoListsAssignedInput;
  todos?: TodoUpdateManyWithoutPartOfInput;
  completed?: Boolean;
  inTeam?: TeamUpdateOneWithoutTodoListsInput;
}

export interface TodoListUpdateManyMutationInput {
  description?: String;
  completed?: Boolean;
}

export interface UserUpdateInput {
  authId?: String;
  name?: String;
  todoListsOwned?: TodoListUpdateManyWithoutOwnedByInput;
  todoListsAssigned?: TodoListUpdateManyWithoutAssignedToInput;
  inTeam?: TeamUpdateManyWithoutMembersInput;
}

export interface UserUpdateManyMutationInput {
  authId?: String;
  name?: String;
}

export interface DocumentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DocumentWhereInput;
  AND?: DocumentSubscriptionWhereInput[] | DocumentSubscriptionWhereInput;
  OR?: DocumentSubscriptionWhereInput[] | DocumentSubscriptionWhereInput;
  NOT?: DocumentSubscriptionWhereInput[] | DocumentSubscriptionWhereInput;
}

export interface DocumentCommentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DocumentCommentWhereInput;
  AND?:
    | DocumentCommentSubscriptionWhereInput[]
    | DocumentCommentSubscriptionWhereInput;
  OR?:
    | DocumentCommentSubscriptionWhereInput[]
    | DocumentCommentSubscriptionWhereInput;
  NOT?:
    | DocumentCommentSubscriptionWhereInput[]
    | DocumentCommentSubscriptionWhereInput;
}

export interface EventSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: EventWhereInput;
  AND?: EventSubscriptionWhereInput[] | EventSubscriptionWhereInput;
  OR?: EventSubscriptionWhereInput[] | EventSubscriptionWhereInput;
  NOT?: EventSubscriptionWhereInput[] | EventSubscriptionWhereInput;
}

export interface FolderSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FolderWhereInput;
  AND?: FolderSubscriptionWhereInput[] | FolderSubscriptionWhereInput;
  OR?: FolderSubscriptionWhereInput[] | FolderSubscriptionWhereInput;
  NOT?: FolderSubscriptionWhereInput[] | FolderSubscriptionWhereInput;
}

export interface MessageSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MessageWhereInput;
  AND?: MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput;
  OR?: MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput;
  NOT?: MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput;
}

export interface MessageCommentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MessageCommentWhereInput;
  AND?:
    | MessageCommentSubscriptionWhereInput[]
    | MessageCommentSubscriptionWhereInput;
  OR?:
    | MessageCommentSubscriptionWhereInput[]
    | MessageCommentSubscriptionWhereInput;
  NOT?:
    | MessageCommentSubscriptionWhereInput[]
    | MessageCommentSubscriptionWhereInput;
}

export interface TagSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TagWhereInput;
  AND?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
  OR?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
  NOT?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
}

export interface TeamSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TeamWhereInput;
  AND?: TeamSubscriptionWhereInput[] | TeamSubscriptionWhereInput;
  OR?: TeamSubscriptionWhereInput[] | TeamSubscriptionWhereInput;
  NOT?: TeamSubscriptionWhereInput[] | TeamSubscriptionWhereInput;
}

export interface TodoSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TodoWhereInput;
  AND?: TodoSubscriptionWhereInput[] | TodoSubscriptionWhereInput;
  OR?: TodoSubscriptionWhereInput[] | TodoSubscriptionWhereInput;
  NOT?: TodoSubscriptionWhereInput[] | TodoSubscriptionWhereInput;
}

export interface TodoListSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TodoListWhereInput;
  AND?: TodoListSubscriptionWhereInput[] | TodoListSubscriptionWhereInput;
  OR?: TodoListSubscriptionWhereInput[] | TodoListSubscriptionWhereInput;
  NOT?: TodoListSubscriptionWhereInput[] | TodoListSubscriptionWhereInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Document {
  id: ID_Output;
  doc_url: String;
  title: String;
  textContent: String;
  images: String[];
  createdAt: DateTimeOutput;
}

export interface DocumentPromise extends Promise<Document>, Fragmentable {
  id: () => Promise<ID_Output>;
  doc_url: () => Promise<String>;
  user: <T = UserPromise>() => T;
  folder: <T = FolderPromise>() => T;
  team: <T = TeamPromise>() => T;
  title: () => Promise<String>;
  textContent: () => Promise<String>;
  tag: <T = TagPromise>() => T;
  images: () => Promise<String[]>;
  comments: <T = FragmentableArray<DocumentComment>>(
    args?: {
      where?: DocumentCommentWhereInput;
      orderBy?: DocumentCommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  subscribedUsers: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface DocumentSubscription
  extends Promise<AsyncIterator<Document>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  doc_url: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
  folder: <T = FolderSubscription>() => T;
  team: <T = TeamSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  textContent: () => Promise<AsyncIterator<String>>;
  tag: <T = TagSubscription>() => T;
  images: () => Promise<AsyncIterator<String[]>>;
  comments: <T = Promise<AsyncIterator<DocumentCommentSubscription>>>(
    args?: {
      where?: DocumentCommentWhereInput;
      orderBy?: DocumentCommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  subscribedUsers: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface User {
  id: ID_Output;
  authId?: String;
  createdAt: DateTimeOutput;
  name?: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  authId: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  todoListsOwned: <T = FragmentableArray<TodoList>>(
    args?: {
      where?: TodoListWhereInput;
      orderBy?: TodoListOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  todoListsAssigned: <T = FragmentableArray<TodoList>>(
    args?: {
      where?: TodoListWhereInput;
      orderBy?: TodoListOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  inTeam: <T = FragmentableArray<Team>>(
    args?: {
      where?: TeamWhereInput;
      orderBy?: TeamOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  authId: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  todoListsOwned: <T = Promise<AsyncIterator<TodoListSubscription>>>(
    args?: {
      where?: TodoListWhereInput;
      orderBy?: TodoListOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  todoListsAssigned: <T = Promise<AsyncIterator<TodoListSubscription>>>(
    args?: {
      where?: TodoListWhereInput;
      orderBy?: TodoListOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  inTeam: <T = Promise<AsyncIterator<TeamSubscription>>>(
    args?: {
      where?: TeamWhereInput;
      orderBy?: TeamOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface TodoList {
  id: ID_Output;
  createdAt: DateTimeOutput;
  description: String;
  completed?: Boolean;
}

export interface TodoListPromise extends Promise<TodoList>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  ownedBy: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  assignedTo: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  todos: <T = FragmentableArray<Todo>>(
    args?: {
      where?: TodoWhereInput;
      orderBy?: TodoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  completed: () => Promise<Boolean>;
  inTeam: <T = TeamPromise>() => T;
}

export interface TodoListSubscription
  extends Promise<AsyncIterator<TodoList>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  ownedBy: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  assignedTo: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  todos: <T = Promise<AsyncIterator<TodoSubscription>>>(
    args?: {
      where?: TodoWhereInput;
      orderBy?: TodoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  completed: () => Promise<AsyncIterator<Boolean>>;
  inTeam: <T = TeamSubscription>() => T;
}

export interface Todo {
  id: ID_Output;
  description: String;
  completed?: Boolean;
}

export interface TodoPromise extends Promise<Todo>, Fragmentable {
  id: () => Promise<ID_Output>;
  description: () => Promise<String>;
  partOf: <T = TodoListPromise>() => T;
  completed: () => Promise<Boolean>;
}

export interface TodoSubscription
  extends Promise<AsyncIterator<Todo>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  description: () => Promise<AsyncIterator<String>>;
  partOf: <T = TodoListSubscription>() => T;
  completed: () => Promise<AsyncIterator<Boolean>>;
}

export interface Team {
  id: ID_Output;
  teamName: String;
}

export interface TeamPromise extends Promise<Team>, Fragmentable {
  id: () => Promise<ID_Output>;
  teamName: () => Promise<String>;
  members: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  todoLists: <T = FragmentableArray<TodoList>>(
    args?: {
      where?: TodoListWhereInput;
      orderBy?: TodoListOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  messages: <T = FragmentableArray<Message>>(
    args?: {
      where?: MessageWhereInput;
      orderBy?: MessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  events: <T = FragmentableArray<Event>>(
    args?: {
      where?: EventWhereInput;
      orderBy?: EventOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  tags: <T = FragmentableArray<Tag>>(
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  documents: <T = FragmentableArray<Document>>(
    args?: {
      where?: DocumentWhereInput;
      orderBy?: DocumentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  folders: <T = FragmentableArray<Folder>>(
    args?: {
      where?: FolderWhereInput;
      orderBy?: FolderOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface TeamSubscription
  extends Promise<AsyncIterator<Team>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  teamName: () => Promise<AsyncIterator<String>>;
  members: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  todoLists: <T = Promise<AsyncIterator<TodoListSubscription>>>(
    args?: {
      where?: TodoListWhereInput;
      orderBy?: TodoListOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  messages: <T = Promise<AsyncIterator<MessageSubscription>>>(
    args?: {
      where?: MessageWhereInput;
      orderBy?: MessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  events: <T = Promise<AsyncIterator<EventSubscription>>>(
    args?: {
      where?: EventWhereInput;
      orderBy?: EventOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  tags: <T = Promise<AsyncIterator<TagSubscription>>>(
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  documents: <T = Promise<AsyncIterator<DocumentSubscription>>>(
    args?: {
      where?: DocumentWhereInput;
      orderBy?: DocumentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  folders: <T = Promise<AsyncIterator<FolderSubscription>>>(
    args?: {
      where?: FolderWhereInput;
      orderBy?: FolderOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface Message {
  id: ID_Output;
  title: String;
  content: String;
  images: String[];
  createdAt: DateTimeOutput;
}

export interface MessagePromise extends Promise<Message>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  creator: <T = UserPromise>() => T;
  inTeam: <T = TeamPromise>() => T;
  content: () => Promise<String>;
  images: () => Promise<String[]>;
  tag: <T = TagPromise>() => T;
  comments: <T = FragmentableArray<MessageComment>>(
    args?: {
      where?: MessageCommentWhereInput;
      orderBy?: MessageCommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  subscribedUsers: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface MessageSubscription
  extends Promise<AsyncIterator<Message>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  creator: <T = UserSubscription>() => T;
  inTeam: <T = TeamSubscription>() => T;
  content: () => Promise<AsyncIterator<String>>;
  images: () => Promise<AsyncIterator<String[]>>;
  tag: <T = TagSubscription>() => T;
  comments: <T = Promise<AsyncIterator<MessageCommentSubscription>>>(
    args?: {
      where?: MessageCommentWhereInput;
      orderBy?: MessageCommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  subscribedUsers: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Tag {
  id: ID_Output;
  name: String;
}

export interface TagPromise extends Promise<Tag>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  team: <T = TeamPromise>() => T;
}

export interface TagSubscription
  extends Promise<AsyncIterator<Tag>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  team: <T = TeamSubscription>() => T;
}

export interface MessageComment {
  id: ID_Output;
  content: String;
  image?: String;
  createdAt: DateTimeOutput;
}

export interface MessageCommentPromise
  extends Promise<MessageComment>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  content: () => Promise<String>;
  user: <T = UserPromise>() => T;
  message: <T = MessagePromise>() => T;
  image: () => Promise<String>;
  likes: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface MessageCommentSubscription
  extends Promise<AsyncIterator<MessageComment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  content: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
  message: <T = MessageSubscription>() => T;
  image: () => Promise<AsyncIterator<String>>;
  likes: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Event {
  id: ID_Output;
  action_string: String;
  object_string: String;
  createdAt: DateTimeOutput;
}

export interface EventPromise extends Promise<Event>, Fragmentable {
  id: () => Promise<ID_Output>;
  team: <T = TeamPromise>() => T;
  user: <T = UserPromise>() => T;
  action_string: () => Promise<String>;
  object_string: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface EventSubscription
  extends Promise<AsyncIterator<Event>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  team: <T = TeamSubscription>() => T;
  user: <T = UserSubscription>() => T;
  action_string: () => Promise<AsyncIterator<String>>;
  object_string: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Folder {
  id: ID_Output;
  title: String;
  createdAt: DateTimeOutput;
}

export interface FolderPromise extends Promise<Folder>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  user: <T = UserPromise>() => T;
  team: <T = TeamPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  documents: <T = FragmentableArray<Document>>(
    args?: {
      where?: DocumentWhereInput;
      orderBy?: DocumentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface FolderSubscription
  extends Promise<AsyncIterator<Folder>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
  team: <T = TeamSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  documents: <T = Promise<AsyncIterator<DocumentSubscription>>>(
    args?: {
      where?: DocumentWhereInput;
      orderBy?: DocumentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface DocumentComment {
  id: ID_Output;
  content: String;
  image?: String;
  createdAt: DateTimeOutput;
}

export interface DocumentCommentPromise
  extends Promise<DocumentComment>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  document: <T = DocumentPromise>() => T;
  content: () => Promise<String>;
  image: () => Promise<String>;
  likes: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface DocumentCommentSubscription
  extends Promise<AsyncIterator<DocumentComment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  document: <T = DocumentSubscription>() => T;
  content: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  likes: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DocumentConnection {
  pageInfo: PageInfo;
  edges: DocumentEdge[];
}

export interface DocumentConnectionPromise
  extends Promise<DocumentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DocumentEdge>>() => T;
  aggregate: <T = AggregateDocumentPromise>() => T;
}

export interface DocumentConnectionSubscription
  extends Promise<AsyncIterator<DocumentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DocumentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDocumentSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface DocumentEdge {
  node: Document;
  cursor: String;
}

export interface DocumentEdgePromise
  extends Promise<DocumentEdge>,
    Fragmentable {
  node: <T = DocumentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DocumentEdgeSubscription
  extends Promise<AsyncIterator<DocumentEdge>>,
    Fragmentable {
  node: <T = DocumentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDocument {
  count: Int;
}

export interface AggregateDocumentPromise
  extends Promise<AggregateDocument>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDocumentSubscription
  extends Promise<AsyncIterator<AggregateDocument>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DocumentCommentConnection {
  pageInfo: PageInfo;
  edges: DocumentCommentEdge[];
}

export interface DocumentCommentConnectionPromise
  extends Promise<DocumentCommentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DocumentCommentEdge>>() => T;
  aggregate: <T = AggregateDocumentCommentPromise>() => T;
}

export interface DocumentCommentConnectionSubscription
  extends Promise<AsyncIterator<DocumentCommentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DocumentCommentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDocumentCommentSubscription>() => T;
}

export interface DocumentCommentEdge {
  node: DocumentComment;
  cursor: String;
}

export interface DocumentCommentEdgePromise
  extends Promise<DocumentCommentEdge>,
    Fragmentable {
  node: <T = DocumentCommentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DocumentCommentEdgeSubscription
  extends Promise<AsyncIterator<DocumentCommentEdge>>,
    Fragmentable {
  node: <T = DocumentCommentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDocumentComment {
  count: Int;
}

export interface AggregateDocumentCommentPromise
  extends Promise<AggregateDocumentComment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDocumentCommentSubscription
  extends Promise<AsyncIterator<AggregateDocumentComment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EventConnection {
  pageInfo: PageInfo;
  edges: EventEdge[];
}

export interface EventConnectionPromise
  extends Promise<EventConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EventEdge>>() => T;
  aggregate: <T = AggregateEventPromise>() => T;
}

export interface EventConnectionSubscription
  extends Promise<AsyncIterator<EventConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EventEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEventSubscription>() => T;
}

export interface EventEdge {
  node: Event;
  cursor: String;
}

export interface EventEdgePromise extends Promise<EventEdge>, Fragmentable {
  node: <T = EventPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EventEdgeSubscription
  extends Promise<AsyncIterator<EventEdge>>,
    Fragmentable {
  node: <T = EventSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEvent {
  count: Int;
}

export interface AggregateEventPromise
  extends Promise<AggregateEvent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEventSubscription
  extends Promise<AsyncIterator<AggregateEvent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FolderConnection {
  pageInfo: PageInfo;
  edges: FolderEdge[];
}

export interface FolderConnectionPromise
  extends Promise<FolderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FolderEdge>>() => T;
  aggregate: <T = AggregateFolderPromise>() => T;
}

export interface FolderConnectionSubscription
  extends Promise<AsyncIterator<FolderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FolderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFolderSubscription>() => T;
}

export interface FolderEdge {
  node: Folder;
  cursor: String;
}

export interface FolderEdgePromise extends Promise<FolderEdge>, Fragmentable {
  node: <T = FolderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FolderEdgeSubscription
  extends Promise<AsyncIterator<FolderEdge>>,
    Fragmentable {
  node: <T = FolderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFolder {
  count: Int;
}

export interface AggregateFolderPromise
  extends Promise<AggregateFolder>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFolderSubscription
  extends Promise<AsyncIterator<AggregateFolder>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MessageConnection {
  pageInfo: PageInfo;
  edges: MessageEdge[];
}

export interface MessageConnectionPromise
  extends Promise<MessageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MessageEdge>>() => T;
  aggregate: <T = AggregateMessagePromise>() => T;
}

export interface MessageConnectionSubscription
  extends Promise<AsyncIterator<MessageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MessageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMessageSubscription>() => T;
}

export interface MessageEdge {
  node: Message;
  cursor: String;
}

export interface MessageEdgePromise extends Promise<MessageEdge>, Fragmentable {
  node: <T = MessagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface MessageEdgeSubscription
  extends Promise<AsyncIterator<MessageEdge>>,
    Fragmentable {
  node: <T = MessageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMessage {
  count: Int;
}

export interface AggregateMessagePromise
  extends Promise<AggregateMessage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMessageSubscription
  extends Promise<AsyncIterator<AggregateMessage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MessageCommentConnection {
  pageInfo: PageInfo;
  edges: MessageCommentEdge[];
}

export interface MessageCommentConnectionPromise
  extends Promise<MessageCommentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MessageCommentEdge>>() => T;
  aggregate: <T = AggregateMessageCommentPromise>() => T;
}

export interface MessageCommentConnectionSubscription
  extends Promise<AsyncIterator<MessageCommentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MessageCommentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMessageCommentSubscription>() => T;
}

export interface MessageCommentEdge {
  node: MessageComment;
  cursor: String;
}

export interface MessageCommentEdgePromise
  extends Promise<MessageCommentEdge>,
    Fragmentable {
  node: <T = MessageCommentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MessageCommentEdgeSubscription
  extends Promise<AsyncIterator<MessageCommentEdge>>,
    Fragmentable {
  node: <T = MessageCommentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMessageComment {
  count: Int;
}

export interface AggregateMessageCommentPromise
  extends Promise<AggregateMessageComment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMessageCommentSubscription
  extends Promise<AsyncIterator<AggregateMessageComment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TagConnection {
  pageInfo: PageInfo;
  edges: TagEdge[];
}

export interface TagConnectionPromise
  extends Promise<TagConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TagEdge>>() => T;
  aggregate: <T = AggregateTagPromise>() => T;
}

export interface TagConnectionSubscription
  extends Promise<AsyncIterator<TagConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TagEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTagSubscription>() => T;
}

export interface TagEdge {
  node: Tag;
  cursor: String;
}

export interface TagEdgePromise extends Promise<TagEdge>, Fragmentable {
  node: <T = TagPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TagEdgeSubscription
  extends Promise<AsyncIterator<TagEdge>>,
    Fragmentable {
  node: <T = TagSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTag {
  count: Int;
}

export interface AggregateTagPromise
  extends Promise<AggregateTag>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTagSubscription
  extends Promise<AsyncIterator<AggregateTag>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TeamConnection {
  pageInfo: PageInfo;
  edges: TeamEdge[];
}

export interface TeamConnectionPromise
  extends Promise<TeamConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TeamEdge>>() => T;
  aggregate: <T = AggregateTeamPromise>() => T;
}

export interface TeamConnectionSubscription
  extends Promise<AsyncIterator<TeamConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TeamEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTeamSubscription>() => T;
}

export interface TeamEdge {
  node: Team;
  cursor: String;
}

export interface TeamEdgePromise extends Promise<TeamEdge>, Fragmentable {
  node: <T = TeamPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TeamEdgeSubscription
  extends Promise<AsyncIterator<TeamEdge>>,
    Fragmentable {
  node: <T = TeamSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTeam {
  count: Int;
}

export interface AggregateTeamPromise
  extends Promise<AggregateTeam>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTeamSubscription
  extends Promise<AsyncIterator<AggregateTeam>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TodoConnection {
  pageInfo: PageInfo;
  edges: TodoEdge[];
}

export interface TodoConnectionPromise
  extends Promise<TodoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TodoEdge>>() => T;
  aggregate: <T = AggregateTodoPromise>() => T;
}

export interface TodoConnectionSubscription
  extends Promise<AsyncIterator<TodoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TodoEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTodoSubscription>() => T;
}

export interface TodoEdge {
  node: Todo;
  cursor: String;
}

export interface TodoEdgePromise extends Promise<TodoEdge>, Fragmentable {
  node: <T = TodoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TodoEdgeSubscription
  extends Promise<AsyncIterator<TodoEdge>>,
    Fragmentable {
  node: <T = TodoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTodo {
  count: Int;
}

export interface AggregateTodoPromise
  extends Promise<AggregateTodo>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTodoSubscription
  extends Promise<AsyncIterator<AggregateTodo>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TodoListConnection {
  pageInfo: PageInfo;
  edges: TodoListEdge[];
}

export interface TodoListConnectionPromise
  extends Promise<TodoListConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TodoListEdge>>() => T;
  aggregate: <T = AggregateTodoListPromise>() => T;
}

export interface TodoListConnectionSubscription
  extends Promise<AsyncIterator<TodoListConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TodoListEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTodoListSubscription>() => T;
}

export interface TodoListEdge {
  node: TodoList;
  cursor: String;
}

export interface TodoListEdgePromise
  extends Promise<TodoListEdge>,
    Fragmentable {
  node: <T = TodoListPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TodoListEdgeSubscription
  extends Promise<AsyncIterator<TodoListEdge>>,
    Fragmentable {
  node: <T = TodoListSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTodoList {
  count: Int;
}

export interface AggregateTodoListPromise
  extends Promise<AggregateTodoList>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTodoListSubscription
  extends Promise<AsyncIterator<AggregateTodoList>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface DocumentSubscriptionPayload {
  mutation: MutationType;
  node: Document;
  updatedFields: String[];
  previousValues: DocumentPreviousValues;
}

export interface DocumentSubscriptionPayloadPromise
  extends Promise<DocumentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DocumentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DocumentPreviousValuesPromise>() => T;
}

export interface DocumentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DocumentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DocumentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DocumentPreviousValuesSubscription>() => T;
}

export interface DocumentPreviousValues {
  id: ID_Output;
  doc_url: String;
  title: String;
  textContent: String;
  images: String[];
  createdAt: DateTimeOutput;
}

export interface DocumentPreviousValuesPromise
  extends Promise<DocumentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  doc_url: () => Promise<String>;
  title: () => Promise<String>;
  textContent: () => Promise<String>;
  images: () => Promise<String[]>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface DocumentPreviousValuesSubscription
  extends Promise<AsyncIterator<DocumentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  doc_url: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  textContent: () => Promise<AsyncIterator<String>>;
  images: () => Promise<AsyncIterator<String[]>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DocumentCommentSubscriptionPayload {
  mutation: MutationType;
  node: DocumentComment;
  updatedFields: String[];
  previousValues: DocumentCommentPreviousValues;
}

export interface DocumentCommentSubscriptionPayloadPromise
  extends Promise<DocumentCommentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DocumentCommentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DocumentCommentPreviousValuesPromise>() => T;
}

export interface DocumentCommentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DocumentCommentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DocumentCommentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DocumentCommentPreviousValuesSubscription>() => T;
}

export interface DocumentCommentPreviousValues {
  id: ID_Output;
  content: String;
  image?: String;
  createdAt: DateTimeOutput;
}

export interface DocumentCommentPreviousValuesPromise
  extends Promise<DocumentCommentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  content: () => Promise<String>;
  image: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface DocumentCommentPreviousValuesSubscription
  extends Promise<AsyncIterator<DocumentCommentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  content: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EventSubscriptionPayload {
  mutation: MutationType;
  node: Event;
  updatedFields: String[];
  previousValues: EventPreviousValues;
}

export interface EventSubscriptionPayloadPromise
  extends Promise<EventSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EventPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EventPreviousValuesPromise>() => T;
}

export interface EventSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EventSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EventSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EventPreviousValuesSubscription>() => T;
}

export interface EventPreviousValues {
  id: ID_Output;
  action_string: String;
  object_string: String;
  createdAt: DateTimeOutput;
}

export interface EventPreviousValuesPromise
  extends Promise<EventPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  action_string: () => Promise<String>;
  object_string: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface EventPreviousValuesSubscription
  extends Promise<AsyncIterator<EventPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  action_string: () => Promise<AsyncIterator<String>>;
  object_string: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FolderSubscriptionPayload {
  mutation: MutationType;
  node: Folder;
  updatedFields: String[];
  previousValues: FolderPreviousValues;
}

export interface FolderSubscriptionPayloadPromise
  extends Promise<FolderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FolderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FolderPreviousValuesPromise>() => T;
}

export interface FolderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FolderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FolderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FolderPreviousValuesSubscription>() => T;
}

export interface FolderPreviousValues {
  id: ID_Output;
  title: String;
  createdAt: DateTimeOutput;
}

export interface FolderPreviousValuesPromise
  extends Promise<FolderPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface FolderPreviousValuesSubscription
  extends Promise<AsyncIterator<FolderPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MessageSubscriptionPayload {
  mutation: MutationType;
  node: Message;
  updatedFields: String[];
  previousValues: MessagePreviousValues;
}

export interface MessageSubscriptionPayloadPromise
  extends Promise<MessageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MessagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MessagePreviousValuesPromise>() => T;
}

export interface MessageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MessageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MessageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MessagePreviousValuesSubscription>() => T;
}

export interface MessagePreviousValues {
  id: ID_Output;
  title: String;
  content: String;
  images: String[];
  createdAt: DateTimeOutput;
}

export interface MessagePreviousValuesPromise
  extends Promise<MessagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  content: () => Promise<String>;
  images: () => Promise<String[]>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface MessagePreviousValuesSubscription
  extends Promise<AsyncIterator<MessagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  images: () => Promise<AsyncIterator<String[]>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MessageCommentSubscriptionPayload {
  mutation: MutationType;
  node: MessageComment;
  updatedFields: String[];
  previousValues: MessageCommentPreviousValues;
}

export interface MessageCommentSubscriptionPayloadPromise
  extends Promise<MessageCommentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MessageCommentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MessageCommentPreviousValuesPromise>() => T;
}

export interface MessageCommentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MessageCommentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MessageCommentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MessageCommentPreviousValuesSubscription>() => T;
}

export interface MessageCommentPreviousValues {
  id: ID_Output;
  content: String;
  image?: String;
  createdAt: DateTimeOutput;
}

export interface MessageCommentPreviousValuesPromise
  extends Promise<MessageCommentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  content: () => Promise<String>;
  image: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface MessageCommentPreviousValuesSubscription
  extends Promise<AsyncIterator<MessageCommentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  content: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TagSubscriptionPayload {
  mutation: MutationType;
  node: Tag;
  updatedFields: String[];
  previousValues: TagPreviousValues;
}

export interface TagSubscriptionPayloadPromise
  extends Promise<TagSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TagPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TagPreviousValuesPromise>() => T;
}

export interface TagSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TagSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TagSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TagPreviousValuesSubscription>() => T;
}

export interface TagPreviousValues {
  id: ID_Output;
  name: String;
}

export interface TagPreviousValuesPromise
  extends Promise<TagPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface TagPreviousValuesSubscription
  extends Promise<AsyncIterator<TagPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface TeamSubscriptionPayload {
  mutation: MutationType;
  node: Team;
  updatedFields: String[];
  previousValues: TeamPreviousValues;
}

export interface TeamSubscriptionPayloadPromise
  extends Promise<TeamSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TeamPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TeamPreviousValuesPromise>() => T;
}

export interface TeamSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TeamSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TeamSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TeamPreviousValuesSubscription>() => T;
}

export interface TeamPreviousValues {
  id: ID_Output;
  teamName: String;
}

export interface TeamPreviousValuesPromise
  extends Promise<TeamPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  teamName: () => Promise<String>;
}

export interface TeamPreviousValuesSubscription
  extends Promise<AsyncIterator<TeamPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  teamName: () => Promise<AsyncIterator<String>>;
}

export interface TodoSubscriptionPayload {
  mutation: MutationType;
  node: Todo;
  updatedFields: String[];
  previousValues: TodoPreviousValues;
}

export interface TodoSubscriptionPayloadPromise
  extends Promise<TodoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TodoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TodoPreviousValuesPromise>() => T;
}

export interface TodoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TodoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TodoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TodoPreviousValuesSubscription>() => T;
}

export interface TodoPreviousValues {
  id: ID_Output;
  description: String;
  completed?: Boolean;
}

export interface TodoPreviousValuesPromise
  extends Promise<TodoPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  description: () => Promise<String>;
  completed: () => Promise<Boolean>;
}

export interface TodoPreviousValuesSubscription
  extends Promise<AsyncIterator<TodoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  description: () => Promise<AsyncIterator<String>>;
  completed: () => Promise<AsyncIterator<Boolean>>;
}

export interface TodoListSubscriptionPayload {
  mutation: MutationType;
  node: TodoList;
  updatedFields: String[];
  previousValues: TodoListPreviousValues;
}

export interface TodoListSubscriptionPayloadPromise
  extends Promise<TodoListSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TodoListPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TodoListPreviousValuesPromise>() => T;
}

export interface TodoListSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TodoListSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TodoListSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TodoListPreviousValuesSubscription>() => T;
}

export interface TodoListPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  description: String;
  completed?: Boolean;
}

export interface TodoListPreviousValuesPromise
  extends Promise<TodoListPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  completed: () => Promise<Boolean>;
}

export interface TodoListPreviousValuesSubscription
  extends Promise<AsyncIterator<TodoListPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  completed: () => Promise<AsyncIterator<Boolean>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  authId?: String;
  createdAt: DateTimeOutput;
  name?: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  authId: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  authId: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Role",
    embedded: false
  },
  {
    name: "TodoList",
    embedded: false
  },
  {
    name: "Todo",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Team",
    embedded: false
  },
  {
    name: "Message",
    embedded: false
  },
  {
    name: "MessageComment",
    embedded: false
  },
  {
    name: "Tag",
    embedded: false
  },
  {
    name: "Event",
    embedded: false
  },
  {
    name: "Document",
    embedded: false
  },
  {
    name: "DocumentComment",
    embedded: false
  },
  {
    name: "Folder",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
