module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.29.1). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateDocument {
  count: Int!
}

type AggregateDocumentComment {
  count: Int!
}

type AggregateEvent {
  count: Int!
}

type AggregateFolder {
  count: Int!
}

type AggregateMessage {
  count: Int!
}

type AggregateMessageComment {
  count: Int!
}

type AggregateTag {
  count: Int!
}

type AggregateTeam {
  count: Int!
}

type AggregateTodo {
  count: Int!
}

type AggregateTodoList {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

type Document {
  id: ID!
  doc_url: String!
  user: User!
  folder: Folder
  team: Team!
  title: String!
  textContent: String!
  tag: Tag
  images: [String!]!
  comments(where: DocumentCommentWhereInput, orderBy: DocumentCommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [DocumentComment!]
  subscribedUsers(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  createdAt: DateTime!
}

type DocumentComment {
  id: ID!
  user: User!
  document: Document!
  content: String!
  image: String
  likes(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  createdAt: DateTime!
}

type DocumentCommentConnection {
  pageInfo: PageInfo!
  edges: [DocumentCommentEdge]!
  aggregate: AggregateDocumentComment!
}

input DocumentCommentCreateInput {
  user: UserCreateOneInput!
  document: DocumentCreateOneWithoutCommentsInput!
  content: String!
  image: String
  likes: UserCreateManyInput
}

input DocumentCommentCreateManyWithoutDocumentInput {
  create: [DocumentCommentCreateWithoutDocumentInput!]
  connect: [DocumentCommentWhereUniqueInput!]
}

input DocumentCommentCreateWithoutDocumentInput {
  user: UserCreateOneInput!
  content: String!
  image: String
  likes: UserCreateManyInput
}

type DocumentCommentEdge {
  node: DocumentComment!
  cursor: String!
}

enum DocumentCommentOrderByInput {
  id_ASC
  id_DESC
  content_ASC
  content_DESC
  image_ASC
  image_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type DocumentCommentPreviousValues {
  id: ID!
  content: String!
  image: String
  createdAt: DateTime!
}

input DocumentCommentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [DocumentCommentScalarWhereInput!]
  OR: [DocumentCommentScalarWhereInput!]
  NOT: [DocumentCommentScalarWhereInput!]
}

type DocumentCommentSubscriptionPayload {
  mutation: MutationType!
  node: DocumentComment
  updatedFields: [String!]
  previousValues: DocumentCommentPreviousValues
}

input DocumentCommentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DocumentCommentWhereInput
  AND: [DocumentCommentSubscriptionWhereInput!]
  OR: [DocumentCommentSubscriptionWhereInput!]
  NOT: [DocumentCommentSubscriptionWhereInput!]
}

input DocumentCommentUpdateInput {
  user: UserUpdateOneRequiredInput
  document: DocumentUpdateOneRequiredWithoutCommentsInput
  content: String
  image: String
  likes: UserUpdateManyInput
}

input DocumentCommentUpdateManyDataInput {
  content: String
  image: String
}

input DocumentCommentUpdateManyMutationInput {
  content: String
  image: String
}

input DocumentCommentUpdateManyWithoutDocumentInput {
  create: [DocumentCommentCreateWithoutDocumentInput!]
  delete: [DocumentCommentWhereUniqueInput!]
  connect: [DocumentCommentWhereUniqueInput!]
  set: [DocumentCommentWhereUniqueInput!]
  disconnect: [DocumentCommentWhereUniqueInput!]
  update: [DocumentCommentUpdateWithWhereUniqueWithoutDocumentInput!]
  upsert: [DocumentCommentUpsertWithWhereUniqueWithoutDocumentInput!]
  deleteMany: [DocumentCommentScalarWhereInput!]
  updateMany: [DocumentCommentUpdateManyWithWhereNestedInput!]
}

input DocumentCommentUpdateManyWithWhereNestedInput {
  where: DocumentCommentScalarWhereInput!
  data: DocumentCommentUpdateManyDataInput!
}

input DocumentCommentUpdateWithoutDocumentDataInput {
  user: UserUpdateOneRequiredInput
  content: String
  image: String
  likes: UserUpdateManyInput
}

input DocumentCommentUpdateWithWhereUniqueWithoutDocumentInput {
  where: DocumentCommentWhereUniqueInput!
  data: DocumentCommentUpdateWithoutDocumentDataInput!
}

input DocumentCommentUpsertWithWhereUniqueWithoutDocumentInput {
  where: DocumentCommentWhereUniqueInput!
  update: DocumentCommentUpdateWithoutDocumentDataInput!
  create: DocumentCommentCreateWithoutDocumentInput!
}

input DocumentCommentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  document: DocumentWhereInput
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  likes_every: UserWhereInput
  likes_some: UserWhereInput
  likes_none: UserWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [DocumentCommentWhereInput!]
  OR: [DocumentCommentWhereInput!]
  NOT: [DocumentCommentWhereInput!]
}

input DocumentCommentWhereUniqueInput {
  id: ID
}

type DocumentConnection {
  pageInfo: PageInfo!
  edges: [DocumentEdge]!
  aggregate: AggregateDocument!
}

input DocumentCreateimagesInput {
  set: [String!]
}

input DocumentCreateInput {
  doc_url: String!
  user: UserCreateOneInput!
  folder: FolderCreateOneWithoutDocumentsInput
  team: TeamCreateOneWithoutDocumentsInput!
  title: String!
  textContent: String!
  tag: TagCreateOneInput
  images: DocumentCreateimagesInput
  comments: DocumentCommentCreateManyWithoutDocumentInput
  subscribedUsers: UserCreateManyInput
}

input DocumentCreateManyWithoutFolderInput {
  create: [DocumentCreateWithoutFolderInput!]
  connect: [DocumentWhereUniqueInput!]
}

input DocumentCreateManyWithoutTeamInput {
  create: [DocumentCreateWithoutTeamInput!]
  connect: [DocumentWhereUniqueInput!]
}

input DocumentCreateOneWithoutCommentsInput {
  create: DocumentCreateWithoutCommentsInput
  connect: DocumentWhereUniqueInput
}

input DocumentCreateWithoutCommentsInput {
  doc_url: String!
  user: UserCreateOneInput!
  folder: FolderCreateOneWithoutDocumentsInput
  team: TeamCreateOneWithoutDocumentsInput!
  title: String!
  textContent: String!
  tag: TagCreateOneInput
  images: DocumentCreateimagesInput
  subscribedUsers: UserCreateManyInput
}

input DocumentCreateWithoutFolderInput {
  doc_url: String!
  user: UserCreateOneInput!
  team: TeamCreateOneWithoutDocumentsInput!
  title: String!
  textContent: String!
  tag: TagCreateOneInput
  images: DocumentCreateimagesInput
  comments: DocumentCommentCreateManyWithoutDocumentInput
  subscribedUsers: UserCreateManyInput
}

input DocumentCreateWithoutTeamInput {
  doc_url: String!
  user: UserCreateOneInput!
  folder: FolderCreateOneWithoutDocumentsInput
  title: String!
  textContent: String!
  tag: TagCreateOneInput
  images: DocumentCreateimagesInput
  comments: DocumentCommentCreateManyWithoutDocumentInput
  subscribedUsers: UserCreateManyInput
}

type DocumentEdge {
  node: Document!
  cursor: String!
}

enum DocumentOrderByInput {
  id_ASC
  id_DESC
  doc_url_ASC
  doc_url_DESC
  title_ASC
  title_DESC
  textContent_ASC
  textContent_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type DocumentPreviousValues {
  id: ID!
  doc_url: String!
  title: String!
  textContent: String!
  images: [String!]!
  createdAt: DateTime!
}

input DocumentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  doc_url: String
  doc_url_not: String
  doc_url_in: [String!]
  doc_url_not_in: [String!]
  doc_url_lt: String
  doc_url_lte: String
  doc_url_gt: String
  doc_url_gte: String
  doc_url_contains: String
  doc_url_not_contains: String
  doc_url_starts_with: String
  doc_url_not_starts_with: String
  doc_url_ends_with: String
  doc_url_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  textContent: String
  textContent_not: String
  textContent_in: [String!]
  textContent_not_in: [String!]
  textContent_lt: String
  textContent_lte: String
  textContent_gt: String
  textContent_gte: String
  textContent_contains: String
  textContent_not_contains: String
  textContent_starts_with: String
  textContent_not_starts_with: String
  textContent_ends_with: String
  textContent_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [DocumentScalarWhereInput!]
  OR: [DocumentScalarWhereInput!]
  NOT: [DocumentScalarWhereInput!]
}

type DocumentSubscriptionPayload {
  mutation: MutationType!
  node: Document
  updatedFields: [String!]
  previousValues: DocumentPreviousValues
}

input DocumentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DocumentWhereInput
  AND: [DocumentSubscriptionWhereInput!]
  OR: [DocumentSubscriptionWhereInput!]
  NOT: [DocumentSubscriptionWhereInput!]
}

input DocumentUpdateimagesInput {
  set: [String!]
}

input DocumentUpdateInput {
  doc_url: String
  user: UserUpdateOneRequiredInput
  folder: FolderUpdateOneWithoutDocumentsInput
  team: TeamUpdateOneRequiredWithoutDocumentsInput
  title: String
  textContent: String
  tag: TagUpdateOneInput
  images: DocumentUpdateimagesInput
  comments: DocumentCommentUpdateManyWithoutDocumentInput
  subscribedUsers: UserUpdateManyInput
}

input DocumentUpdateManyDataInput {
  doc_url: String
  title: String
  textContent: String
  images: DocumentUpdateimagesInput
}

input DocumentUpdateManyMutationInput {
  doc_url: String
  title: String
  textContent: String
  images: DocumentUpdateimagesInput
}

input DocumentUpdateManyWithoutFolderInput {
  create: [DocumentCreateWithoutFolderInput!]
  delete: [DocumentWhereUniqueInput!]
  connect: [DocumentWhereUniqueInput!]
  set: [DocumentWhereUniqueInput!]
  disconnect: [DocumentWhereUniqueInput!]
  update: [DocumentUpdateWithWhereUniqueWithoutFolderInput!]
  upsert: [DocumentUpsertWithWhereUniqueWithoutFolderInput!]
  deleteMany: [DocumentScalarWhereInput!]
  updateMany: [DocumentUpdateManyWithWhereNestedInput!]
}

input DocumentUpdateManyWithoutTeamInput {
  create: [DocumentCreateWithoutTeamInput!]
  delete: [DocumentWhereUniqueInput!]
  connect: [DocumentWhereUniqueInput!]
  set: [DocumentWhereUniqueInput!]
  disconnect: [DocumentWhereUniqueInput!]
  update: [DocumentUpdateWithWhereUniqueWithoutTeamInput!]
  upsert: [DocumentUpsertWithWhereUniqueWithoutTeamInput!]
  deleteMany: [DocumentScalarWhereInput!]
  updateMany: [DocumentUpdateManyWithWhereNestedInput!]
}

input DocumentUpdateManyWithWhereNestedInput {
  where: DocumentScalarWhereInput!
  data: DocumentUpdateManyDataInput!
}

input DocumentUpdateOneRequiredWithoutCommentsInput {
  create: DocumentCreateWithoutCommentsInput
  update: DocumentUpdateWithoutCommentsDataInput
  upsert: DocumentUpsertWithoutCommentsInput
  connect: DocumentWhereUniqueInput
}

input DocumentUpdateWithoutCommentsDataInput {
  doc_url: String
  user: UserUpdateOneRequiredInput
  folder: FolderUpdateOneWithoutDocumentsInput
  team: TeamUpdateOneRequiredWithoutDocumentsInput
  title: String
  textContent: String
  tag: TagUpdateOneInput
  images: DocumentUpdateimagesInput
  subscribedUsers: UserUpdateManyInput
}

input DocumentUpdateWithoutFolderDataInput {
  doc_url: String
  user: UserUpdateOneRequiredInput
  team: TeamUpdateOneRequiredWithoutDocumentsInput
  title: String
  textContent: String
  tag: TagUpdateOneInput
  images: DocumentUpdateimagesInput
  comments: DocumentCommentUpdateManyWithoutDocumentInput
  subscribedUsers: UserUpdateManyInput
}

input DocumentUpdateWithoutTeamDataInput {
  doc_url: String
  user: UserUpdateOneRequiredInput
  folder: FolderUpdateOneWithoutDocumentsInput
  title: String
  textContent: String
  tag: TagUpdateOneInput
  images: DocumentUpdateimagesInput
  comments: DocumentCommentUpdateManyWithoutDocumentInput
  subscribedUsers: UserUpdateManyInput
}

input DocumentUpdateWithWhereUniqueWithoutFolderInput {
  where: DocumentWhereUniqueInput!
  data: DocumentUpdateWithoutFolderDataInput!
}

input DocumentUpdateWithWhereUniqueWithoutTeamInput {
  where: DocumentWhereUniqueInput!
  data: DocumentUpdateWithoutTeamDataInput!
}

input DocumentUpsertWithoutCommentsInput {
  update: DocumentUpdateWithoutCommentsDataInput!
  create: DocumentCreateWithoutCommentsInput!
}

input DocumentUpsertWithWhereUniqueWithoutFolderInput {
  where: DocumentWhereUniqueInput!
  update: DocumentUpdateWithoutFolderDataInput!
  create: DocumentCreateWithoutFolderInput!
}

input DocumentUpsertWithWhereUniqueWithoutTeamInput {
  where: DocumentWhereUniqueInput!
  update: DocumentUpdateWithoutTeamDataInput!
  create: DocumentCreateWithoutTeamInput!
}

input DocumentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  doc_url: String
  doc_url_not: String
  doc_url_in: [String!]
  doc_url_not_in: [String!]
  doc_url_lt: String
  doc_url_lte: String
  doc_url_gt: String
  doc_url_gte: String
  doc_url_contains: String
  doc_url_not_contains: String
  doc_url_starts_with: String
  doc_url_not_starts_with: String
  doc_url_ends_with: String
  doc_url_not_ends_with: String
  user: UserWhereInput
  folder: FolderWhereInput
  team: TeamWhereInput
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  textContent: String
  textContent_not: String
  textContent_in: [String!]
  textContent_not_in: [String!]
  textContent_lt: String
  textContent_lte: String
  textContent_gt: String
  textContent_gte: String
  textContent_contains: String
  textContent_not_contains: String
  textContent_starts_with: String
  textContent_not_starts_with: String
  textContent_ends_with: String
  textContent_not_ends_with: String
  tag: TagWhereInput
  comments_every: DocumentCommentWhereInput
  comments_some: DocumentCommentWhereInput
  comments_none: DocumentCommentWhereInput
  subscribedUsers_every: UserWhereInput
  subscribedUsers_some: UserWhereInput
  subscribedUsers_none: UserWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [DocumentWhereInput!]
  OR: [DocumentWhereInput!]
  NOT: [DocumentWhereInput!]
}

input DocumentWhereUniqueInput {
  id: ID
}

type Event {
  id: ID!
  team: Team!
  user: User
  action_string: String!
  object_string: String!
  createdAt: DateTime!
}

type EventConnection {
  pageInfo: PageInfo!
  edges: [EventEdge]!
  aggregate: AggregateEvent!
}

input EventCreateInput {
  team: TeamCreateOneWithoutEventsInput!
  user: UserCreateOneInput
  action_string: String!
  object_string: String!
}

input EventCreateManyWithoutTeamInput {
  create: [EventCreateWithoutTeamInput!]
  connect: [EventWhereUniqueInput!]
}

input EventCreateWithoutTeamInput {
  user: UserCreateOneInput
  action_string: String!
  object_string: String!
}

type EventEdge {
  node: Event!
  cursor: String!
}

enum EventOrderByInput {
  id_ASC
  id_DESC
  action_string_ASC
  action_string_DESC
  object_string_ASC
  object_string_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type EventPreviousValues {
  id: ID!
  action_string: String!
  object_string: String!
  createdAt: DateTime!
}

input EventScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  action_string: String
  action_string_not: String
  action_string_in: [String!]
  action_string_not_in: [String!]
  action_string_lt: String
  action_string_lte: String
  action_string_gt: String
  action_string_gte: String
  action_string_contains: String
  action_string_not_contains: String
  action_string_starts_with: String
  action_string_not_starts_with: String
  action_string_ends_with: String
  action_string_not_ends_with: String
  object_string: String
  object_string_not: String
  object_string_in: [String!]
  object_string_not_in: [String!]
  object_string_lt: String
  object_string_lte: String
  object_string_gt: String
  object_string_gte: String
  object_string_contains: String
  object_string_not_contains: String
  object_string_starts_with: String
  object_string_not_starts_with: String
  object_string_ends_with: String
  object_string_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [EventScalarWhereInput!]
  OR: [EventScalarWhereInput!]
  NOT: [EventScalarWhereInput!]
}

type EventSubscriptionPayload {
  mutation: MutationType!
  node: Event
  updatedFields: [String!]
  previousValues: EventPreviousValues
}

input EventSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EventWhereInput
  AND: [EventSubscriptionWhereInput!]
  OR: [EventSubscriptionWhereInput!]
  NOT: [EventSubscriptionWhereInput!]
}

input EventUpdateInput {
  team: TeamUpdateOneRequiredWithoutEventsInput
  user: UserUpdateOneInput
  action_string: String
  object_string: String
}

input EventUpdateManyDataInput {
  action_string: String
  object_string: String
}

input EventUpdateManyMutationInput {
  action_string: String
  object_string: String
}

input EventUpdateManyWithoutTeamInput {
  create: [EventCreateWithoutTeamInput!]
  delete: [EventWhereUniqueInput!]
  connect: [EventWhereUniqueInput!]
  set: [EventWhereUniqueInput!]
  disconnect: [EventWhereUniqueInput!]
  update: [EventUpdateWithWhereUniqueWithoutTeamInput!]
  upsert: [EventUpsertWithWhereUniqueWithoutTeamInput!]
  deleteMany: [EventScalarWhereInput!]
  updateMany: [EventUpdateManyWithWhereNestedInput!]
}

input EventUpdateManyWithWhereNestedInput {
  where: EventScalarWhereInput!
  data: EventUpdateManyDataInput!
}

input EventUpdateWithoutTeamDataInput {
  user: UserUpdateOneInput
  action_string: String
  object_string: String
}

input EventUpdateWithWhereUniqueWithoutTeamInput {
  where: EventWhereUniqueInput!
  data: EventUpdateWithoutTeamDataInput!
}

input EventUpsertWithWhereUniqueWithoutTeamInput {
  where: EventWhereUniqueInput!
  update: EventUpdateWithoutTeamDataInput!
  create: EventCreateWithoutTeamInput!
}

input EventWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  team: TeamWhereInput
  user: UserWhereInput
  action_string: String
  action_string_not: String
  action_string_in: [String!]
  action_string_not_in: [String!]
  action_string_lt: String
  action_string_lte: String
  action_string_gt: String
  action_string_gte: String
  action_string_contains: String
  action_string_not_contains: String
  action_string_starts_with: String
  action_string_not_starts_with: String
  action_string_ends_with: String
  action_string_not_ends_with: String
  object_string: String
  object_string_not: String
  object_string_in: [String!]
  object_string_not_in: [String!]
  object_string_lt: String
  object_string_lte: String
  object_string_gt: String
  object_string_gte: String
  object_string_contains: String
  object_string_not_contains: String
  object_string_starts_with: String
  object_string_not_starts_with: String
  object_string_ends_with: String
  object_string_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [EventWhereInput!]
  OR: [EventWhereInput!]
  NOT: [EventWhereInput!]
}

input EventWhereUniqueInput {
  id: ID
}

type Folder {
  id: ID!
  title: String!
  user: User!
  team: Team!
  createdAt: DateTime!
  documents(where: DocumentWhereInput, orderBy: DocumentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Document!]
}

type FolderConnection {
  pageInfo: PageInfo!
  edges: [FolderEdge]!
  aggregate: AggregateFolder!
}

input FolderCreateInput {
  title: String!
  user: UserCreateOneInput!
  team: TeamCreateOneWithoutFoldersInput!
  documents: DocumentCreateManyWithoutFolderInput
}

input FolderCreateManyWithoutTeamInput {
  create: [FolderCreateWithoutTeamInput!]
  connect: [FolderWhereUniqueInput!]
}

input FolderCreateOneWithoutDocumentsInput {
  create: FolderCreateWithoutDocumentsInput
  connect: FolderWhereUniqueInput
}

input FolderCreateWithoutDocumentsInput {
  title: String!
  user: UserCreateOneInput!
  team: TeamCreateOneWithoutFoldersInput!
}

input FolderCreateWithoutTeamInput {
  title: String!
  user: UserCreateOneInput!
  documents: DocumentCreateManyWithoutFolderInput
}

type FolderEdge {
  node: Folder!
  cursor: String!
}

enum FolderOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type FolderPreviousValues {
  id: ID!
  title: String!
  createdAt: DateTime!
}

input FolderScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [FolderScalarWhereInput!]
  OR: [FolderScalarWhereInput!]
  NOT: [FolderScalarWhereInput!]
}

type FolderSubscriptionPayload {
  mutation: MutationType!
  node: Folder
  updatedFields: [String!]
  previousValues: FolderPreviousValues
}

input FolderSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FolderWhereInput
  AND: [FolderSubscriptionWhereInput!]
  OR: [FolderSubscriptionWhereInput!]
  NOT: [FolderSubscriptionWhereInput!]
}

input FolderUpdateInput {
  title: String
  user: UserUpdateOneRequiredInput
  team: TeamUpdateOneRequiredWithoutFoldersInput
  documents: DocumentUpdateManyWithoutFolderInput
}

input FolderUpdateManyDataInput {
  title: String
}

input FolderUpdateManyMutationInput {
  title: String
}

input FolderUpdateManyWithoutTeamInput {
  create: [FolderCreateWithoutTeamInput!]
  delete: [FolderWhereUniqueInput!]
  connect: [FolderWhereUniqueInput!]
  set: [FolderWhereUniqueInput!]
  disconnect: [FolderWhereUniqueInput!]
  update: [FolderUpdateWithWhereUniqueWithoutTeamInput!]
  upsert: [FolderUpsertWithWhereUniqueWithoutTeamInput!]
  deleteMany: [FolderScalarWhereInput!]
  updateMany: [FolderUpdateManyWithWhereNestedInput!]
}

input FolderUpdateManyWithWhereNestedInput {
  where: FolderScalarWhereInput!
  data: FolderUpdateManyDataInput!
}

input FolderUpdateOneWithoutDocumentsInput {
  create: FolderCreateWithoutDocumentsInput
  update: FolderUpdateWithoutDocumentsDataInput
  upsert: FolderUpsertWithoutDocumentsInput
  delete: Boolean
  disconnect: Boolean
  connect: FolderWhereUniqueInput
}

input FolderUpdateWithoutDocumentsDataInput {
  title: String
  user: UserUpdateOneRequiredInput
  team: TeamUpdateOneRequiredWithoutFoldersInput
}

input FolderUpdateWithoutTeamDataInput {
  title: String
  user: UserUpdateOneRequiredInput
  documents: DocumentUpdateManyWithoutFolderInput
}

input FolderUpdateWithWhereUniqueWithoutTeamInput {
  where: FolderWhereUniqueInput!
  data: FolderUpdateWithoutTeamDataInput!
}

input FolderUpsertWithoutDocumentsInput {
  update: FolderUpdateWithoutDocumentsDataInput!
  create: FolderCreateWithoutDocumentsInput!
}

input FolderUpsertWithWhereUniqueWithoutTeamInput {
  where: FolderWhereUniqueInput!
  update: FolderUpdateWithoutTeamDataInput!
  create: FolderCreateWithoutTeamInput!
}

input FolderWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  user: UserWhereInput
  team: TeamWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  documents_every: DocumentWhereInput
  documents_some: DocumentWhereInput
  documents_none: DocumentWhereInput
  AND: [FolderWhereInput!]
  OR: [FolderWhereInput!]
  NOT: [FolderWhereInput!]
}

input FolderWhereUniqueInput {
  id: ID
}

scalar Long

type Message {
  id: ID!
  title: String!
  creator: User!
  inTeam: Team!
  content: String!
  images: [String!]!
  tag: Tag
  comments(where: MessageCommentWhereInput, orderBy: MessageCommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MessageComment!]
  subscribedUsers(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  createdAt: DateTime!
}

type MessageComment {
  id: ID!
  content: String!
  user: User!
  message: Message!
  image: String
  likes(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  createdAt: DateTime!
}

type MessageCommentConnection {
  pageInfo: PageInfo!
  edges: [MessageCommentEdge]!
  aggregate: AggregateMessageComment!
}

input MessageCommentCreateInput {
  content: String!
  user: UserCreateOneInput!
  message: MessageCreateOneWithoutCommentsInput!
  image: String
  likes: UserCreateManyInput
}

input MessageCommentCreateManyWithoutMessageInput {
  create: [MessageCommentCreateWithoutMessageInput!]
  connect: [MessageCommentWhereUniqueInput!]
}

input MessageCommentCreateWithoutMessageInput {
  content: String!
  user: UserCreateOneInput!
  image: String
  likes: UserCreateManyInput
}

type MessageCommentEdge {
  node: MessageComment!
  cursor: String!
}

enum MessageCommentOrderByInput {
  id_ASC
  id_DESC
  content_ASC
  content_DESC
  image_ASC
  image_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type MessageCommentPreviousValues {
  id: ID!
  content: String!
  image: String
  createdAt: DateTime!
}

input MessageCommentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [MessageCommentScalarWhereInput!]
  OR: [MessageCommentScalarWhereInput!]
  NOT: [MessageCommentScalarWhereInput!]
}

type MessageCommentSubscriptionPayload {
  mutation: MutationType!
  node: MessageComment
  updatedFields: [String!]
  previousValues: MessageCommentPreviousValues
}

input MessageCommentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MessageCommentWhereInput
  AND: [MessageCommentSubscriptionWhereInput!]
  OR: [MessageCommentSubscriptionWhereInput!]
  NOT: [MessageCommentSubscriptionWhereInput!]
}

input MessageCommentUpdateInput {
  content: String
  user: UserUpdateOneRequiredInput
  message: MessageUpdateOneRequiredWithoutCommentsInput
  image: String
  likes: UserUpdateManyInput
}

input MessageCommentUpdateManyDataInput {
  content: String
  image: String
}

input MessageCommentUpdateManyMutationInput {
  content: String
  image: String
}

input MessageCommentUpdateManyWithoutMessageInput {
  create: [MessageCommentCreateWithoutMessageInput!]
  delete: [MessageCommentWhereUniqueInput!]
  connect: [MessageCommentWhereUniqueInput!]
  set: [MessageCommentWhereUniqueInput!]
  disconnect: [MessageCommentWhereUniqueInput!]
  update: [MessageCommentUpdateWithWhereUniqueWithoutMessageInput!]
  upsert: [MessageCommentUpsertWithWhereUniqueWithoutMessageInput!]
  deleteMany: [MessageCommentScalarWhereInput!]
  updateMany: [MessageCommentUpdateManyWithWhereNestedInput!]
}

input MessageCommentUpdateManyWithWhereNestedInput {
  where: MessageCommentScalarWhereInput!
  data: MessageCommentUpdateManyDataInput!
}

input MessageCommentUpdateWithoutMessageDataInput {
  content: String
  user: UserUpdateOneRequiredInput
  image: String
  likes: UserUpdateManyInput
}

input MessageCommentUpdateWithWhereUniqueWithoutMessageInput {
  where: MessageCommentWhereUniqueInput!
  data: MessageCommentUpdateWithoutMessageDataInput!
}

input MessageCommentUpsertWithWhereUniqueWithoutMessageInput {
  where: MessageCommentWhereUniqueInput!
  update: MessageCommentUpdateWithoutMessageDataInput!
  create: MessageCommentCreateWithoutMessageInput!
}

input MessageCommentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  user: UserWhereInput
  message: MessageWhereInput
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  likes_every: UserWhereInput
  likes_some: UserWhereInput
  likes_none: UserWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [MessageCommentWhereInput!]
  OR: [MessageCommentWhereInput!]
  NOT: [MessageCommentWhereInput!]
}

input MessageCommentWhereUniqueInput {
  id: ID
}

type MessageConnection {
  pageInfo: PageInfo!
  edges: [MessageEdge]!
  aggregate: AggregateMessage!
}

input MessageCreateimagesInput {
  set: [String!]
}

input MessageCreateInput {
  title: String!
  creator: UserCreateOneInput!
  inTeam: TeamCreateOneWithoutMessagesInput!
  content: String!
  images: MessageCreateimagesInput
  tag: TagCreateOneInput
  comments: MessageCommentCreateManyWithoutMessageInput
  subscribedUsers: UserCreateManyInput
}

input MessageCreateManyWithoutInTeamInput {
  create: [MessageCreateWithoutInTeamInput!]
  connect: [MessageWhereUniqueInput!]
}

input MessageCreateOneWithoutCommentsInput {
  create: MessageCreateWithoutCommentsInput
  connect: MessageWhereUniqueInput
}

input MessageCreateWithoutCommentsInput {
  title: String!
  creator: UserCreateOneInput!
  inTeam: TeamCreateOneWithoutMessagesInput!
  content: String!
  images: MessageCreateimagesInput
  tag: TagCreateOneInput
  subscribedUsers: UserCreateManyInput
}

input MessageCreateWithoutInTeamInput {
  title: String!
  creator: UserCreateOneInput!
  content: String!
  images: MessageCreateimagesInput
  tag: TagCreateOneInput
  comments: MessageCommentCreateManyWithoutMessageInput
  subscribedUsers: UserCreateManyInput
}

type MessageEdge {
  node: Message!
  cursor: String!
}

enum MessageOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  content_ASC
  content_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type MessagePreviousValues {
  id: ID!
  title: String!
  content: String!
  images: [String!]!
  createdAt: DateTime!
}

input MessageScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [MessageScalarWhereInput!]
  OR: [MessageScalarWhereInput!]
  NOT: [MessageScalarWhereInput!]
}

type MessageSubscriptionPayload {
  mutation: MutationType!
  node: Message
  updatedFields: [String!]
  previousValues: MessagePreviousValues
}

input MessageSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MessageWhereInput
  AND: [MessageSubscriptionWhereInput!]
  OR: [MessageSubscriptionWhereInput!]
  NOT: [MessageSubscriptionWhereInput!]
}

input MessageUpdateimagesInput {
  set: [String!]
}

input MessageUpdateInput {
  title: String
  creator: UserUpdateOneRequiredInput
  inTeam: TeamUpdateOneRequiredWithoutMessagesInput
  content: String
  images: MessageUpdateimagesInput
  tag: TagUpdateOneInput
  comments: MessageCommentUpdateManyWithoutMessageInput
  subscribedUsers: UserUpdateManyInput
}

input MessageUpdateManyDataInput {
  title: String
  content: String
  images: MessageUpdateimagesInput
}

input MessageUpdateManyMutationInput {
  title: String
  content: String
  images: MessageUpdateimagesInput
}

input MessageUpdateManyWithoutInTeamInput {
  create: [MessageCreateWithoutInTeamInput!]
  delete: [MessageWhereUniqueInput!]
  connect: [MessageWhereUniqueInput!]
  set: [MessageWhereUniqueInput!]
  disconnect: [MessageWhereUniqueInput!]
  update: [MessageUpdateWithWhereUniqueWithoutInTeamInput!]
  upsert: [MessageUpsertWithWhereUniqueWithoutInTeamInput!]
  deleteMany: [MessageScalarWhereInput!]
  updateMany: [MessageUpdateManyWithWhereNestedInput!]
}

input MessageUpdateManyWithWhereNestedInput {
  where: MessageScalarWhereInput!
  data: MessageUpdateManyDataInput!
}

input MessageUpdateOneRequiredWithoutCommentsInput {
  create: MessageCreateWithoutCommentsInput
  update: MessageUpdateWithoutCommentsDataInput
  upsert: MessageUpsertWithoutCommentsInput
  connect: MessageWhereUniqueInput
}

input MessageUpdateWithoutCommentsDataInput {
  title: String
  creator: UserUpdateOneRequiredInput
  inTeam: TeamUpdateOneRequiredWithoutMessagesInput
  content: String
  images: MessageUpdateimagesInput
  tag: TagUpdateOneInput
  subscribedUsers: UserUpdateManyInput
}

input MessageUpdateWithoutInTeamDataInput {
  title: String
  creator: UserUpdateOneRequiredInput
  content: String
  images: MessageUpdateimagesInput
  tag: TagUpdateOneInput
  comments: MessageCommentUpdateManyWithoutMessageInput
  subscribedUsers: UserUpdateManyInput
}

input MessageUpdateWithWhereUniqueWithoutInTeamInput {
  where: MessageWhereUniqueInput!
  data: MessageUpdateWithoutInTeamDataInput!
}

input MessageUpsertWithoutCommentsInput {
  update: MessageUpdateWithoutCommentsDataInput!
  create: MessageCreateWithoutCommentsInput!
}

input MessageUpsertWithWhereUniqueWithoutInTeamInput {
  where: MessageWhereUniqueInput!
  update: MessageUpdateWithoutInTeamDataInput!
  create: MessageCreateWithoutInTeamInput!
}

input MessageWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  creator: UserWhereInput
  inTeam: TeamWhereInput
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  tag: TagWhereInput
  comments_every: MessageCommentWhereInput
  comments_some: MessageCommentWhereInput
  comments_none: MessageCommentWhereInput
  subscribedUsers_every: UserWhereInput
  subscribedUsers_some: UserWhereInput
  subscribedUsers_none: UserWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [MessageWhereInput!]
  OR: [MessageWhereInput!]
  NOT: [MessageWhereInput!]
}

input MessageWhereUniqueInput {
  id: ID
}

type Mutation {
  createDocument(data: DocumentCreateInput!): Document!
  updateDocument(data: DocumentUpdateInput!, where: DocumentWhereUniqueInput!): Document
  updateManyDocuments(data: DocumentUpdateManyMutationInput!, where: DocumentWhereInput): BatchPayload!
  upsertDocument(where: DocumentWhereUniqueInput!, create: DocumentCreateInput!, update: DocumentUpdateInput!): Document!
  deleteDocument(where: DocumentWhereUniqueInput!): Document
  deleteManyDocuments(where: DocumentWhereInput): BatchPayload!
  createDocumentComment(data: DocumentCommentCreateInput!): DocumentComment!
  updateDocumentComment(data: DocumentCommentUpdateInput!, where: DocumentCommentWhereUniqueInput!): DocumentComment
  updateManyDocumentComments(data: DocumentCommentUpdateManyMutationInput!, where: DocumentCommentWhereInput): BatchPayload!
  upsertDocumentComment(where: DocumentCommentWhereUniqueInput!, create: DocumentCommentCreateInput!, update: DocumentCommentUpdateInput!): DocumentComment!
  deleteDocumentComment(where: DocumentCommentWhereUniqueInput!): DocumentComment
  deleteManyDocumentComments(where: DocumentCommentWhereInput): BatchPayload!
  createEvent(data: EventCreateInput!): Event!
  updateEvent(data: EventUpdateInput!, where: EventWhereUniqueInput!): Event
  updateManyEvents(data: EventUpdateManyMutationInput!, where: EventWhereInput): BatchPayload!
  upsertEvent(where: EventWhereUniqueInput!, create: EventCreateInput!, update: EventUpdateInput!): Event!
  deleteEvent(where: EventWhereUniqueInput!): Event
  deleteManyEvents(where: EventWhereInput): BatchPayload!
  createFolder(data: FolderCreateInput!): Folder!
  updateFolder(data: FolderUpdateInput!, where: FolderWhereUniqueInput!): Folder
  updateManyFolders(data: FolderUpdateManyMutationInput!, where: FolderWhereInput): BatchPayload!
  upsertFolder(where: FolderWhereUniqueInput!, create: FolderCreateInput!, update: FolderUpdateInput!): Folder!
  deleteFolder(where: FolderWhereUniqueInput!): Folder
  deleteManyFolders(where: FolderWhereInput): BatchPayload!
  createMessage(data: MessageCreateInput!): Message!
  updateMessage(data: MessageUpdateInput!, where: MessageWhereUniqueInput!): Message
  updateManyMessages(data: MessageUpdateManyMutationInput!, where: MessageWhereInput): BatchPayload!
  upsertMessage(where: MessageWhereUniqueInput!, create: MessageCreateInput!, update: MessageUpdateInput!): Message!
  deleteMessage(where: MessageWhereUniqueInput!): Message
  deleteManyMessages(where: MessageWhereInput): BatchPayload!
  createMessageComment(data: MessageCommentCreateInput!): MessageComment!
  updateMessageComment(data: MessageCommentUpdateInput!, where: MessageCommentWhereUniqueInput!): MessageComment
  updateManyMessageComments(data: MessageCommentUpdateManyMutationInput!, where: MessageCommentWhereInput): BatchPayload!
  upsertMessageComment(where: MessageCommentWhereUniqueInput!, create: MessageCommentCreateInput!, update: MessageCommentUpdateInput!): MessageComment!
  deleteMessageComment(where: MessageCommentWhereUniqueInput!): MessageComment
  deleteManyMessageComments(where: MessageCommentWhereInput): BatchPayload!
  createTag(data: TagCreateInput!): Tag!
  updateTag(data: TagUpdateInput!, where: TagWhereUniqueInput!): Tag
  updateManyTags(data: TagUpdateManyMutationInput!, where: TagWhereInput): BatchPayload!
  upsertTag(where: TagWhereUniqueInput!, create: TagCreateInput!, update: TagUpdateInput!): Tag!
  deleteTag(where: TagWhereUniqueInput!): Tag
  deleteManyTags(where: TagWhereInput): BatchPayload!
  createTeam(data: TeamCreateInput!): Team!
  updateTeam(data: TeamUpdateInput!, where: TeamWhereUniqueInput!): Team
  updateManyTeams(data: TeamUpdateManyMutationInput!, where: TeamWhereInput): BatchPayload!
  upsertTeam(where: TeamWhereUniqueInput!, create: TeamCreateInput!, update: TeamUpdateInput!): Team!
  deleteTeam(where: TeamWhereUniqueInput!): Team
  deleteManyTeams(where: TeamWhereInput): BatchPayload!
  createTodo(data: TodoCreateInput!): Todo!
  updateTodo(data: TodoUpdateInput!, where: TodoWhereUniqueInput!): Todo
  updateManyTodoes(data: TodoUpdateManyMutationInput!, where: TodoWhereInput): BatchPayload!
  upsertTodo(where: TodoWhereUniqueInput!, create: TodoCreateInput!, update: TodoUpdateInput!): Todo!
  deleteTodo(where: TodoWhereUniqueInput!): Todo
  deleteManyTodoes(where: TodoWhereInput): BatchPayload!
  createTodoList(data: TodoListCreateInput!): TodoList!
  updateTodoList(data: TodoListUpdateInput!, where: TodoListWhereUniqueInput!): TodoList
  updateManyTodoLists(data: TodoListUpdateManyMutationInput!, where: TodoListWhereInput): BatchPayload!
  upsertTodoList(where: TodoListWhereUniqueInput!, create: TodoListCreateInput!, update: TodoListUpdateInput!): TodoList!
  deleteTodoList(where: TodoListWhereUniqueInput!): TodoList
  deleteManyTodoLists(where: TodoListWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  document(where: DocumentWhereUniqueInput!): Document
  documents(where: DocumentWhereInput, orderBy: DocumentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Document]!
  documentsConnection(where: DocumentWhereInput, orderBy: DocumentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DocumentConnection!
  documentComment(where: DocumentCommentWhereUniqueInput!): DocumentComment
  documentComments(where: DocumentCommentWhereInput, orderBy: DocumentCommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [DocumentComment]!
  documentCommentsConnection(where: DocumentCommentWhereInput, orderBy: DocumentCommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DocumentCommentConnection!
  event(where: EventWhereUniqueInput!): Event
  events(where: EventWhereInput, orderBy: EventOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Event]!
  eventsConnection(where: EventWhereInput, orderBy: EventOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EventConnection!
  folder(where: FolderWhereUniqueInput!): Folder
  folders(where: FolderWhereInput, orderBy: FolderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Folder]!
  foldersConnection(where: FolderWhereInput, orderBy: FolderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FolderConnection!
  message(where: MessageWhereUniqueInput!): Message
  messages(where: MessageWhereInput, orderBy: MessageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Message]!
  messagesConnection(where: MessageWhereInput, orderBy: MessageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MessageConnection!
  messageComment(where: MessageCommentWhereUniqueInput!): MessageComment
  messageComments(where: MessageCommentWhereInput, orderBy: MessageCommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MessageComment]!
  messageCommentsConnection(where: MessageCommentWhereInput, orderBy: MessageCommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MessageCommentConnection!
  tag(where: TagWhereUniqueInput!): Tag
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag]!
  tagsConnection(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TagConnection!
  team(where: TeamWhereUniqueInput!): Team
  teams(where: TeamWhereInput, orderBy: TeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Team]!
  teamsConnection(where: TeamWhereInput, orderBy: TeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TeamConnection!
  todo(where: TodoWhereUniqueInput!): Todo
  todoes(where: TodoWhereInput, orderBy: TodoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Todo]!
  todoesConnection(where: TodoWhereInput, orderBy: TodoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TodoConnection!
  todoList(where: TodoListWhereUniqueInput!): TodoList
  todoLists(where: TodoListWhereInput, orderBy: TodoListOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TodoList]!
  todoListsConnection(where: TodoListWhereInput, orderBy: TodoListOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TodoListConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

enum Role {
  ADMIN
  GENERAL
}

type Subscription {
  document(where: DocumentSubscriptionWhereInput): DocumentSubscriptionPayload
  documentComment(where: DocumentCommentSubscriptionWhereInput): DocumentCommentSubscriptionPayload
  event(where: EventSubscriptionWhereInput): EventSubscriptionPayload
  folder(where: FolderSubscriptionWhereInput): FolderSubscriptionPayload
  message(where: MessageSubscriptionWhereInput): MessageSubscriptionPayload
  messageComment(where: MessageCommentSubscriptionWhereInput): MessageCommentSubscriptionPayload
  tag(where: TagSubscriptionWhereInput): TagSubscriptionPayload
  team(where: TeamSubscriptionWhereInput): TeamSubscriptionPayload
  todo(where: TodoSubscriptionWhereInput): TodoSubscriptionPayload
  todoList(where: TodoListSubscriptionWhereInput): TodoListSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type Tag {
  id: ID!
  name: String!
  team: Team
}

type TagConnection {
  pageInfo: PageInfo!
  edges: [TagEdge]!
  aggregate: AggregateTag!
}

input TagCreateInput {
  name: String!
  team: TeamCreateOneWithoutTagsInput
}

input TagCreateManyWithoutTeamInput {
  create: [TagCreateWithoutTeamInput!]
  connect: [TagWhereUniqueInput!]
}

input TagCreateOneInput {
  create: TagCreateInput
  connect: TagWhereUniqueInput
}

input TagCreateWithoutTeamInput {
  name: String!
}

type TagEdge {
  node: Tag!
  cursor: String!
}

enum TagOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TagPreviousValues {
  id: ID!
  name: String!
}

input TagScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [TagScalarWhereInput!]
  OR: [TagScalarWhereInput!]
  NOT: [TagScalarWhereInput!]
}

type TagSubscriptionPayload {
  mutation: MutationType!
  node: Tag
  updatedFields: [String!]
  previousValues: TagPreviousValues
}

input TagSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TagWhereInput
  AND: [TagSubscriptionWhereInput!]
  OR: [TagSubscriptionWhereInput!]
  NOT: [TagSubscriptionWhereInput!]
}

input TagUpdateDataInput {
  name: String
  team: TeamUpdateOneWithoutTagsInput
}

input TagUpdateInput {
  name: String
  team: TeamUpdateOneWithoutTagsInput
}

input TagUpdateManyDataInput {
  name: String
}

input TagUpdateManyMutationInput {
  name: String
}

input TagUpdateManyWithoutTeamInput {
  create: [TagCreateWithoutTeamInput!]
  delete: [TagWhereUniqueInput!]
  connect: [TagWhereUniqueInput!]
  set: [TagWhereUniqueInput!]
  disconnect: [TagWhereUniqueInput!]
  update: [TagUpdateWithWhereUniqueWithoutTeamInput!]
  upsert: [TagUpsertWithWhereUniqueWithoutTeamInput!]
  deleteMany: [TagScalarWhereInput!]
  updateMany: [TagUpdateManyWithWhereNestedInput!]
}

input TagUpdateManyWithWhereNestedInput {
  where: TagScalarWhereInput!
  data: TagUpdateManyDataInput!
}

input TagUpdateOneInput {
  create: TagCreateInput
  update: TagUpdateDataInput
  upsert: TagUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: TagWhereUniqueInput
}

input TagUpdateWithoutTeamDataInput {
  name: String
}

input TagUpdateWithWhereUniqueWithoutTeamInput {
  where: TagWhereUniqueInput!
  data: TagUpdateWithoutTeamDataInput!
}

input TagUpsertNestedInput {
  update: TagUpdateDataInput!
  create: TagCreateInput!
}

input TagUpsertWithWhereUniqueWithoutTeamInput {
  where: TagWhereUniqueInput!
  update: TagUpdateWithoutTeamDataInput!
  create: TagCreateWithoutTeamInput!
}

input TagWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  team: TeamWhereInput
  AND: [TagWhereInput!]
  OR: [TagWhereInput!]
  NOT: [TagWhereInput!]
}

input TagWhereUniqueInput {
  id: ID
}

type Team {
  id: ID!
  teamName: String!
  members(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  todoLists(where: TodoListWhereInput, orderBy: TodoListOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TodoList!]
  messages(where: MessageWhereInput, orderBy: MessageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Message!]
  events(where: EventWhereInput, orderBy: EventOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Event!]
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag!]
  documents(where: DocumentWhereInput, orderBy: DocumentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Document!]
  folders(where: FolderWhereInput, orderBy: FolderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Folder!]
}

type TeamConnection {
  pageInfo: PageInfo!
  edges: [TeamEdge]!
  aggregate: AggregateTeam!
}

input TeamCreateInput {
  teamName: String!
  members: UserCreateManyWithoutInTeamInput
  todoLists: TodoListCreateManyWithoutInTeamInput
  messages: MessageCreateManyWithoutInTeamInput
  events: EventCreateManyWithoutTeamInput
  tags: TagCreateManyWithoutTeamInput
  documents: DocumentCreateManyWithoutTeamInput
  folders: FolderCreateManyWithoutTeamInput
}

input TeamCreateManyWithoutMembersInput {
  create: [TeamCreateWithoutMembersInput!]
  connect: [TeamWhereUniqueInput!]
}

input TeamCreateOneWithoutDocumentsInput {
  create: TeamCreateWithoutDocumentsInput
  connect: TeamWhereUniqueInput
}

input TeamCreateOneWithoutEventsInput {
  create: TeamCreateWithoutEventsInput
  connect: TeamWhereUniqueInput
}

input TeamCreateOneWithoutFoldersInput {
  create: TeamCreateWithoutFoldersInput
  connect: TeamWhereUniqueInput
}

input TeamCreateOneWithoutMessagesInput {
  create: TeamCreateWithoutMessagesInput
  connect: TeamWhereUniqueInput
}

input TeamCreateOneWithoutTagsInput {
  create: TeamCreateWithoutTagsInput
  connect: TeamWhereUniqueInput
}

input TeamCreateOneWithoutTodoListsInput {
  create: TeamCreateWithoutTodoListsInput
  connect: TeamWhereUniqueInput
}

input TeamCreateWithoutDocumentsInput {
  teamName: String!
  members: UserCreateManyWithoutInTeamInput
  todoLists: TodoListCreateManyWithoutInTeamInput
  messages: MessageCreateManyWithoutInTeamInput
  events: EventCreateManyWithoutTeamInput
  tags: TagCreateManyWithoutTeamInput
  folders: FolderCreateManyWithoutTeamInput
}

input TeamCreateWithoutEventsInput {
  teamName: String!
  members: UserCreateManyWithoutInTeamInput
  todoLists: TodoListCreateManyWithoutInTeamInput
  messages: MessageCreateManyWithoutInTeamInput
  tags: TagCreateManyWithoutTeamInput
  documents: DocumentCreateManyWithoutTeamInput
  folders: FolderCreateManyWithoutTeamInput
}

input TeamCreateWithoutFoldersInput {
  teamName: String!
  members: UserCreateManyWithoutInTeamInput
  todoLists: TodoListCreateManyWithoutInTeamInput
  messages: MessageCreateManyWithoutInTeamInput
  events: EventCreateManyWithoutTeamInput
  tags: TagCreateManyWithoutTeamInput
  documents: DocumentCreateManyWithoutTeamInput
}

input TeamCreateWithoutMembersInput {
  teamName: String!
  todoLists: TodoListCreateManyWithoutInTeamInput
  messages: MessageCreateManyWithoutInTeamInput
  events: EventCreateManyWithoutTeamInput
  tags: TagCreateManyWithoutTeamInput
  documents: DocumentCreateManyWithoutTeamInput
  folders: FolderCreateManyWithoutTeamInput
}

input TeamCreateWithoutMessagesInput {
  teamName: String!
  members: UserCreateManyWithoutInTeamInput
  todoLists: TodoListCreateManyWithoutInTeamInput
  events: EventCreateManyWithoutTeamInput
  tags: TagCreateManyWithoutTeamInput
  documents: DocumentCreateManyWithoutTeamInput
  folders: FolderCreateManyWithoutTeamInput
}

input TeamCreateWithoutTagsInput {
  teamName: String!
  members: UserCreateManyWithoutInTeamInput
  todoLists: TodoListCreateManyWithoutInTeamInput
  messages: MessageCreateManyWithoutInTeamInput
  events: EventCreateManyWithoutTeamInput
  documents: DocumentCreateManyWithoutTeamInput
  folders: FolderCreateManyWithoutTeamInput
}

input TeamCreateWithoutTodoListsInput {
  teamName: String!
  members: UserCreateManyWithoutInTeamInput
  messages: MessageCreateManyWithoutInTeamInput
  events: EventCreateManyWithoutTeamInput
  tags: TagCreateManyWithoutTeamInput
  documents: DocumentCreateManyWithoutTeamInput
  folders: FolderCreateManyWithoutTeamInput
}

type TeamEdge {
  node: Team!
  cursor: String!
}

enum TeamOrderByInput {
  id_ASC
  id_DESC
  teamName_ASC
  teamName_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TeamPreviousValues {
  id: ID!
  teamName: String!
}

input TeamScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  teamName: String
  teamName_not: String
  teamName_in: [String!]
  teamName_not_in: [String!]
  teamName_lt: String
  teamName_lte: String
  teamName_gt: String
  teamName_gte: String
  teamName_contains: String
  teamName_not_contains: String
  teamName_starts_with: String
  teamName_not_starts_with: String
  teamName_ends_with: String
  teamName_not_ends_with: String
  AND: [TeamScalarWhereInput!]
  OR: [TeamScalarWhereInput!]
  NOT: [TeamScalarWhereInput!]
}

type TeamSubscriptionPayload {
  mutation: MutationType!
  node: Team
  updatedFields: [String!]
  previousValues: TeamPreviousValues
}

input TeamSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TeamWhereInput
  AND: [TeamSubscriptionWhereInput!]
  OR: [TeamSubscriptionWhereInput!]
  NOT: [TeamSubscriptionWhereInput!]
}

input TeamUpdateInput {
  teamName: String
  members: UserUpdateManyWithoutInTeamInput
  todoLists: TodoListUpdateManyWithoutInTeamInput
  messages: MessageUpdateManyWithoutInTeamInput
  events: EventUpdateManyWithoutTeamInput
  tags: TagUpdateManyWithoutTeamInput
  documents: DocumentUpdateManyWithoutTeamInput
  folders: FolderUpdateManyWithoutTeamInput
}

input TeamUpdateManyDataInput {
  teamName: String
}

input TeamUpdateManyMutationInput {
  teamName: String
}

input TeamUpdateManyWithoutMembersInput {
  create: [TeamCreateWithoutMembersInput!]
  delete: [TeamWhereUniqueInput!]
  connect: [TeamWhereUniqueInput!]
  set: [TeamWhereUniqueInput!]
  disconnect: [TeamWhereUniqueInput!]
  update: [TeamUpdateWithWhereUniqueWithoutMembersInput!]
  upsert: [TeamUpsertWithWhereUniqueWithoutMembersInput!]
  deleteMany: [TeamScalarWhereInput!]
  updateMany: [TeamUpdateManyWithWhereNestedInput!]
}

input TeamUpdateManyWithWhereNestedInput {
  where: TeamScalarWhereInput!
  data: TeamUpdateManyDataInput!
}

input TeamUpdateOneRequiredWithoutDocumentsInput {
  create: TeamCreateWithoutDocumentsInput
  update: TeamUpdateWithoutDocumentsDataInput
  upsert: TeamUpsertWithoutDocumentsInput
  connect: TeamWhereUniqueInput
}

input TeamUpdateOneRequiredWithoutEventsInput {
  create: TeamCreateWithoutEventsInput
  update: TeamUpdateWithoutEventsDataInput
  upsert: TeamUpsertWithoutEventsInput
  connect: TeamWhereUniqueInput
}

input TeamUpdateOneRequiredWithoutFoldersInput {
  create: TeamCreateWithoutFoldersInput
  update: TeamUpdateWithoutFoldersDataInput
  upsert: TeamUpsertWithoutFoldersInput
  connect: TeamWhereUniqueInput
}

input TeamUpdateOneRequiredWithoutMessagesInput {
  create: TeamCreateWithoutMessagesInput
  update: TeamUpdateWithoutMessagesDataInput
  upsert: TeamUpsertWithoutMessagesInput
  connect: TeamWhereUniqueInput
}

input TeamUpdateOneWithoutTagsInput {
  create: TeamCreateWithoutTagsInput
  update: TeamUpdateWithoutTagsDataInput
  upsert: TeamUpsertWithoutTagsInput
  delete: Boolean
  disconnect: Boolean
  connect: TeamWhereUniqueInput
}

input TeamUpdateOneWithoutTodoListsInput {
  create: TeamCreateWithoutTodoListsInput
  update: TeamUpdateWithoutTodoListsDataInput
  upsert: TeamUpsertWithoutTodoListsInput
  delete: Boolean
  disconnect: Boolean
  connect: TeamWhereUniqueInput
}

input TeamUpdateWithoutDocumentsDataInput {
  teamName: String
  members: UserUpdateManyWithoutInTeamInput
  todoLists: TodoListUpdateManyWithoutInTeamInput
  messages: MessageUpdateManyWithoutInTeamInput
  events: EventUpdateManyWithoutTeamInput
  tags: TagUpdateManyWithoutTeamInput
  folders: FolderUpdateManyWithoutTeamInput
}

input TeamUpdateWithoutEventsDataInput {
  teamName: String
  members: UserUpdateManyWithoutInTeamInput
  todoLists: TodoListUpdateManyWithoutInTeamInput
  messages: MessageUpdateManyWithoutInTeamInput
  tags: TagUpdateManyWithoutTeamInput
  documents: DocumentUpdateManyWithoutTeamInput
  folders: FolderUpdateManyWithoutTeamInput
}

input TeamUpdateWithoutFoldersDataInput {
  teamName: String
  members: UserUpdateManyWithoutInTeamInput
  todoLists: TodoListUpdateManyWithoutInTeamInput
  messages: MessageUpdateManyWithoutInTeamInput
  events: EventUpdateManyWithoutTeamInput
  tags: TagUpdateManyWithoutTeamInput
  documents: DocumentUpdateManyWithoutTeamInput
}

input TeamUpdateWithoutMembersDataInput {
  teamName: String
  todoLists: TodoListUpdateManyWithoutInTeamInput
  messages: MessageUpdateManyWithoutInTeamInput
  events: EventUpdateManyWithoutTeamInput
  tags: TagUpdateManyWithoutTeamInput
  documents: DocumentUpdateManyWithoutTeamInput
  folders: FolderUpdateManyWithoutTeamInput
}

input TeamUpdateWithoutMessagesDataInput {
  teamName: String
  members: UserUpdateManyWithoutInTeamInput
  todoLists: TodoListUpdateManyWithoutInTeamInput
  events: EventUpdateManyWithoutTeamInput
  tags: TagUpdateManyWithoutTeamInput
  documents: DocumentUpdateManyWithoutTeamInput
  folders: FolderUpdateManyWithoutTeamInput
}

input TeamUpdateWithoutTagsDataInput {
  teamName: String
  members: UserUpdateManyWithoutInTeamInput
  todoLists: TodoListUpdateManyWithoutInTeamInput
  messages: MessageUpdateManyWithoutInTeamInput
  events: EventUpdateManyWithoutTeamInput
  documents: DocumentUpdateManyWithoutTeamInput
  folders: FolderUpdateManyWithoutTeamInput
}

input TeamUpdateWithoutTodoListsDataInput {
  teamName: String
  members: UserUpdateManyWithoutInTeamInput
  messages: MessageUpdateManyWithoutInTeamInput
  events: EventUpdateManyWithoutTeamInput
  tags: TagUpdateManyWithoutTeamInput
  documents: DocumentUpdateManyWithoutTeamInput
  folders: FolderUpdateManyWithoutTeamInput
}

input TeamUpdateWithWhereUniqueWithoutMembersInput {
  where: TeamWhereUniqueInput!
  data: TeamUpdateWithoutMembersDataInput!
}

input TeamUpsertWithoutDocumentsInput {
  update: TeamUpdateWithoutDocumentsDataInput!
  create: TeamCreateWithoutDocumentsInput!
}

input TeamUpsertWithoutEventsInput {
  update: TeamUpdateWithoutEventsDataInput!
  create: TeamCreateWithoutEventsInput!
}

input TeamUpsertWithoutFoldersInput {
  update: TeamUpdateWithoutFoldersDataInput!
  create: TeamCreateWithoutFoldersInput!
}

input TeamUpsertWithoutMessagesInput {
  update: TeamUpdateWithoutMessagesDataInput!
  create: TeamCreateWithoutMessagesInput!
}

input TeamUpsertWithoutTagsInput {
  update: TeamUpdateWithoutTagsDataInput!
  create: TeamCreateWithoutTagsInput!
}

input TeamUpsertWithoutTodoListsInput {
  update: TeamUpdateWithoutTodoListsDataInput!
  create: TeamCreateWithoutTodoListsInput!
}

input TeamUpsertWithWhereUniqueWithoutMembersInput {
  where: TeamWhereUniqueInput!
  update: TeamUpdateWithoutMembersDataInput!
  create: TeamCreateWithoutMembersInput!
}

input TeamWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  teamName: String
  teamName_not: String
  teamName_in: [String!]
  teamName_not_in: [String!]
  teamName_lt: String
  teamName_lte: String
  teamName_gt: String
  teamName_gte: String
  teamName_contains: String
  teamName_not_contains: String
  teamName_starts_with: String
  teamName_not_starts_with: String
  teamName_ends_with: String
  teamName_not_ends_with: String
  members_every: UserWhereInput
  members_some: UserWhereInput
  members_none: UserWhereInput
  todoLists_every: TodoListWhereInput
  todoLists_some: TodoListWhereInput
  todoLists_none: TodoListWhereInput
  messages_every: MessageWhereInput
  messages_some: MessageWhereInput
  messages_none: MessageWhereInput
  events_every: EventWhereInput
  events_some: EventWhereInput
  events_none: EventWhereInput
  tags_every: TagWhereInput
  tags_some: TagWhereInput
  tags_none: TagWhereInput
  documents_every: DocumentWhereInput
  documents_some: DocumentWhereInput
  documents_none: DocumentWhereInput
  folders_every: FolderWhereInput
  folders_some: FolderWhereInput
  folders_none: FolderWhereInput
  AND: [TeamWhereInput!]
  OR: [TeamWhereInput!]
  NOT: [TeamWhereInput!]
}

input TeamWhereUniqueInput {
  id: ID
}

type Todo {
  id: ID!
  description: String!
  partOf: TodoList
  completed: Boolean
}

type TodoConnection {
  pageInfo: PageInfo!
  edges: [TodoEdge]!
  aggregate: AggregateTodo!
}

input TodoCreateInput {
  description: String!
  partOf: TodoListCreateOneWithoutTodosInput
  completed: Boolean
}

input TodoCreateManyWithoutPartOfInput {
  create: [TodoCreateWithoutPartOfInput!]
  connect: [TodoWhereUniqueInput!]
}

input TodoCreateWithoutPartOfInput {
  description: String!
  completed: Boolean
}

type TodoEdge {
  node: Todo!
  cursor: String!
}

type TodoList {
  id: ID!
  createdAt: DateTime!
  description: String!
  ownedBy(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  assignedTo(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  todos(where: TodoWhereInput, orderBy: TodoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Todo!]
  completed: Boolean
  inTeam: Team
}

type TodoListConnection {
  pageInfo: PageInfo!
  edges: [TodoListEdge]!
  aggregate: AggregateTodoList!
}

input TodoListCreateInput {
  description: String!
  ownedBy: UserCreateManyWithoutTodoListsOwnedInput
  assignedTo: UserCreateManyWithoutTodoListsAssignedInput
  todos: TodoCreateManyWithoutPartOfInput
  completed: Boolean
  inTeam: TeamCreateOneWithoutTodoListsInput
}

input TodoListCreateManyWithoutAssignedToInput {
  create: [TodoListCreateWithoutAssignedToInput!]
  connect: [TodoListWhereUniqueInput!]
}

input TodoListCreateManyWithoutInTeamInput {
  create: [TodoListCreateWithoutInTeamInput!]
  connect: [TodoListWhereUniqueInput!]
}

input TodoListCreateManyWithoutOwnedByInput {
  create: [TodoListCreateWithoutOwnedByInput!]
  connect: [TodoListWhereUniqueInput!]
}

input TodoListCreateOneWithoutTodosInput {
  create: TodoListCreateWithoutTodosInput
  connect: TodoListWhereUniqueInput
}

input TodoListCreateWithoutAssignedToInput {
  description: String!
  ownedBy: UserCreateManyWithoutTodoListsOwnedInput
  todos: TodoCreateManyWithoutPartOfInput
  completed: Boolean
  inTeam: TeamCreateOneWithoutTodoListsInput
}

input TodoListCreateWithoutInTeamInput {
  description: String!
  ownedBy: UserCreateManyWithoutTodoListsOwnedInput
  assignedTo: UserCreateManyWithoutTodoListsAssignedInput
  todos: TodoCreateManyWithoutPartOfInput
  completed: Boolean
}

input TodoListCreateWithoutOwnedByInput {
  description: String!
  assignedTo: UserCreateManyWithoutTodoListsAssignedInput
  todos: TodoCreateManyWithoutPartOfInput
  completed: Boolean
  inTeam: TeamCreateOneWithoutTodoListsInput
}

input TodoListCreateWithoutTodosInput {
  description: String!
  ownedBy: UserCreateManyWithoutTodoListsOwnedInput
  assignedTo: UserCreateManyWithoutTodoListsAssignedInput
  completed: Boolean
  inTeam: TeamCreateOneWithoutTodoListsInput
}

type TodoListEdge {
  node: TodoList!
  cursor: String!
}

enum TodoListOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  description_ASC
  description_DESC
  completed_ASC
  completed_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TodoListPreviousValues {
  id: ID!
  createdAt: DateTime!
  description: String!
  completed: Boolean
}

input TodoListScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  completed: Boolean
  completed_not: Boolean
  AND: [TodoListScalarWhereInput!]
  OR: [TodoListScalarWhereInput!]
  NOT: [TodoListScalarWhereInput!]
}

type TodoListSubscriptionPayload {
  mutation: MutationType!
  node: TodoList
  updatedFields: [String!]
  previousValues: TodoListPreviousValues
}

input TodoListSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TodoListWhereInput
  AND: [TodoListSubscriptionWhereInput!]
  OR: [TodoListSubscriptionWhereInput!]
  NOT: [TodoListSubscriptionWhereInput!]
}

input TodoListUpdateInput {
  description: String
  ownedBy: UserUpdateManyWithoutTodoListsOwnedInput
  assignedTo: UserUpdateManyWithoutTodoListsAssignedInput
  todos: TodoUpdateManyWithoutPartOfInput
  completed: Boolean
  inTeam: TeamUpdateOneWithoutTodoListsInput
}

input TodoListUpdateManyDataInput {
  description: String
  completed: Boolean
}

input TodoListUpdateManyMutationInput {
  description: String
  completed: Boolean
}

input TodoListUpdateManyWithoutAssignedToInput {
  create: [TodoListCreateWithoutAssignedToInput!]
  delete: [TodoListWhereUniqueInput!]
  connect: [TodoListWhereUniqueInput!]
  set: [TodoListWhereUniqueInput!]
  disconnect: [TodoListWhereUniqueInput!]
  update: [TodoListUpdateWithWhereUniqueWithoutAssignedToInput!]
  upsert: [TodoListUpsertWithWhereUniqueWithoutAssignedToInput!]
  deleteMany: [TodoListScalarWhereInput!]
  updateMany: [TodoListUpdateManyWithWhereNestedInput!]
}

input TodoListUpdateManyWithoutInTeamInput {
  create: [TodoListCreateWithoutInTeamInput!]
  delete: [TodoListWhereUniqueInput!]
  connect: [TodoListWhereUniqueInput!]
  set: [TodoListWhereUniqueInput!]
  disconnect: [TodoListWhereUniqueInput!]
  update: [TodoListUpdateWithWhereUniqueWithoutInTeamInput!]
  upsert: [TodoListUpsertWithWhereUniqueWithoutInTeamInput!]
  deleteMany: [TodoListScalarWhereInput!]
  updateMany: [TodoListUpdateManyWithWhereNestedInput!]
}

input TodoListUpdateManyWithoutOwnedByInput {
  create: [TodoListCreateWithoutOwnedByInput!]
  delete: [TodoListWhereUniqueInput!]
  connect: [TodoListWhereUniqueInput!]
  set: [TodoListWhereUniqueInput!]
  disconnect: [TodoListWhereUniqueInput!]
  update: [TodoListUpdateWithWhereUniqueWithoutOwnedByInput!]
  upsert: [TodoListUpsertWithWhereUniqueWithoutOwnedByInput!]
  deleteMany: [TodoListScalarWhereInput!]
  updateMany: [TodoListUpdateManyWithWhereNestedInput!]
}

input TodoListUpdateManyWithWhereNestedInput {
  where: TodoListScalarWhereInput!
  data: TodoListUpdateManyDataInput!
}

input TodoListUpdateOneWithoutTodosInput {
  create: TodoListCreateWithoutTodosInput
  update: TodoListUpdateWithoutTodosDataInput
  upsert: TodoListUpsertWithoutTodosInput
  delete: Boolean
  disconnect: Boolean
  connect: TodoListWhereUniqueInput
}

input TodoListUpdateWithoutAssignedToDataInput {
  description: String
  ownedBy: UserUpdateManyWithoutTodoListsOwnedInput
  todos: TodoUpdateManyWithoutPartOfInput
  completed: Boolean
  inTeam: TeamUpdateOneWithoutTodoListsInput
}

input TodoListUpdateWithoutInTeamDataInput {
  description: String
  ownedBy: UserUpdateManyWithoutTodoListsOwnedInput
  assignedTo: UserUpdateManyWithoutTodoListsAssignedInput
  todos: TodoUpdateManyWithoutPartOfInput
  completed: Boolean
}

input TodoListUpdateWithoutOwnedByDataInput {
  description: String
  assignedTo: UserUpdateManyWithoutTodoListsAssignedInput
  todos: TodoUpdateManyWithoutPartOfInput
  completed: Boolean
  inTeam: TeamUpdateOneWithoutTodoListsInput
}

input TodoListUpdateWithoutTodosDataInput {
  description: String
  ownedBy: UserUpdateManyWithoutTodoListsOwnedInput
  assignedTo: UserUpdateManyWithoutTodoListsAssignedInput
  completed: Boolean
  inTeam: TeamUpdateOneWithoutTodoListsInput
}

input TodoListUpdateWithWhereUniqueWithoutAssignedToInput {
  where: TodoListWhereUniqueInput!
  data: TodoListUpdateWithoutAssignedToDataInput!
}

input TodoListUpdateWithWhereUniqueWithoutInTeamInput {
  where: TodoListWhereUniqueInput!
  data: TodoListUpdateWithoutInTeamDataInput!
}

input TodoListUpdateWithWhereUniqueWithoutOwnedByInput {
  where: TodoListWhereUniqueInput!
  data: TodoListUpdateWithoutOwnedByDataInput!
}

input TodoListUpsertWithoutTodosInput {
  update: TodoListUpdateWithoutTodosDataInput!
  create: TodoListCreateWithoutTodosInput!
}

input TodoListUpsertWithWhereUniqueWithoutAssignedToInput {
  where: TodoListWhereUniqueInput!
  update: TodoListUpdateWithoutAssignedToDataInput!
  create: TodoListCreateWithoutAssignedToInput!
}

input TodoListUpsertWithWhereUniqueWithoutInTeamInput {
  where: TodoListWhereUniqueInput!
  update: TodoListUpdateWithoutInTeamDataInput!
  create: TodoListCreateWithoutInTeamInput!
}

input TodoListUpsertWithWhereUniqueWithoutOwnedByInput {
  where: TodoListWhereUniqueInput!
  update: TodoListUpdateWithoutOwnedByDataInput!
  create: TodoListCreateWithoutOwnedByInput!
}

input TodoListWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  ownedBy_every: UserWhereInput
  ownedBy_some: UserWhereInput
  ownedBy_none: UserWhereInput
  assignedTo_every: UserWhereInput
  assignedTo_some: UserWhereInput
  assignedTo_none: UserWhereInput
  todos_every: TodoWhereInput
  todos_some: TodoWhereInput
  todos_none: TodoWhereInput
  completed: Boolean
  completed_not: Boolean
  inTeam: TeamWhereInput
  AND: [TodoListWhereInput!]
  OR: [TodoListWhereInput!]
  NOT: [TodoListWhereInput!]
}

input TodoListWhereUniqueInput {
  id: ID
}

enum TodoOrderByInput {
  id_ASC
  id_DESC
  description_ASC
  description_DESC
  completed_ASC
  completed_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TodoPreviousValues {
  id: ID!
  description: String!
  completed: Boolean
}

input TodoScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  completed: Boolean
  completed_not: Boolean
  AND: [TodoScalarWhereInput!]
  OR: [TodoScalarWhereInput!]
  NOT: [TodoScalarWhereInput!]
}

type TodoSubscriptionPayload {
  mutation: MutationType!
  node: Todo
  updatedFields: [String!]
  previousValues: TodoPreviousValues
}

input TodoSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TodoWhereInput
  AND: [TodoSubscriptionWhereInput!]
  OR: [TodoSubscriptionWhereInput!]
  NOT: [TodoSubscriptionWhereInput!]
}

input TodoUpdateInput {
  description: String
  partOf: TodoListUpdateOneWithoutTodosInput
  completed: Boolean
}

input TodoUpdateManyDataInput {
  description: String
  completed: Boolean
}

input TodoUpdateManyMutationInput {
  description: String
  completed: Boolean
}

input TodoUpdateManyWithoutPartOfInput {
  create: [TodoCreateWithoutPartOfInput!]
  delete: [TodoWhereUniqueInput!]
  connect: [TodoWhereUniqueInput!]
  set: [TodoWhereUniqueInput!]
  disconnect: [TodoWhereUniqueInput!]
  update: [TodoUpdateWithWhereUniqueWithoutPartOfInput!]
  upsert: [TodoUpsertWithWhereUniqueWithoutPartOfInput!]
  deleteMany: [TodoScalarWhereInput!]
  updateMany: [TodoUpdateManyWithWhereNestedInput!]
}

input TodoUpdateManyWithWhereNestedInput {
  where: TodoScalarWhereInput!
  data: TodoUpdateManyDataInput!
}

input TodoUpdateWithoutPartOfDataInput {
  description: String
  completed: Boolean
}

input TodoUpdateWithWhereUniqueWithoutPartOfInput {
  where: TodoWhereUniqueInput!
  data: TodoUpdateWithoutPartOfDataInput!
}

input TodoUpsertWithWhereUniqueWithoutPartOfInput {
  where: TodoWhereUniqueInput!
  update: TodoUpdateWithoutPartOfDataInput!
  create: TodoCreateWithoutPartOfInput!
}

input TodoWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  partOf: TodoListWhereInput
  completed: Boolean
  completed_not: Boolean
  AND: [TodoWhereInput!]
  OR: [TodoWhereInput!]
  NOT: [TodoWhereInput!]
}

input TodoWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  authId: String
  createdAt: DateTime!
  identity: String
  name: String
  todoListsOwned(where: TodoListWhereInput, orderBy: TodoListOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TodoList!]
  todoListsAssigned(where: TodoListWhereInput, orderBy: TodoListOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TodoList!]
  inTeam(where: TeamWhereInput, orderBy: TeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Team!]
  role: Role
  email: String
  phone: String
  profilePic: String
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  authId: String
  identity: String
  name: String
  todoListsOwned: TodoListCreateManyWithoutOwnedByInput
  todoListsAssigned: TodoListCreateManyWithoutAssignedToInput
  inTeam: TeamCreateManyWithoutMembersInput
  role: Role
  email: String
  phone: String
  profilePic: String
}

input UserCreateManyInput {
  create: [UserCreateInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateManyWithoutInTeamInput {
  create: [UserCreateWithoutInTeamInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateManyWithoutTodoListsAssignedInput {
  create: [UserCreateWithoutTodoListsAssignedInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateManyWithoutTodoListsOwnedInput {
  create: [UserCreateWithoutTodoListsOwnedInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutInTeamInput {
  authId: String
  identity: String
  name: String
  todoListsOwned: TodoListCreateManyWithoutOwnedByInput
  todoListsAssigned: TodoListCreateManyWithoutAssignedToInput
  role: Role
  email: String
  phone: String
  profilePic: String
}

input UserCreateWithoutTodoListsAssignedInput {
  authId: String
  identity: String
  name: String
  todoListsOwned: TodoListCreateManyWithoutOwnedByInput
  inTeam: TeamCreateManyWithoutMembersInput
  role: Role
  email: String
  phone: String
  profilePic: String
}

input UserCreateWithoutTodoListsOwnedInput {
  authId: String
  identity: String
  name: String
  todoListsAssigned: TodoListCreateManyWithoutAssignedToInput
  inTeam: TeamCreateManyWithoutMembersInput
  role: Role
  email: String
  phone: String
  profilePic: String
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  authId_ASC
  authId_DESC
  createdAt_ASC
  createdAt_DESC
  identity_ASC
  identity_DESC
  name_ASC
  name_DESC
  role_ASC
  role_DESC
  email_ASC
  email_DESC
  phone_ASC
  phone_DESC
  profilePic_ASC
  profilePic_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  authId: String
  createdAt: DateTime!
  identity: String
  name: String
  role: Role
  email: String
  phone: String
  profilePic: String
}

input UserScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  authId: String
  authId_not: String
  authId_in: [String!]
  authId_not_in: [String!]
  authId_lt: String
  authId_lte: String
  authId_gt: String
  authId_gte: String
  authId_contains: String
  authId_not_contains: String
  authId_starts_with: String
  authId_not_starts_with: String
  authId_ends_with: String
  authId_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  identity: String
  identity_not: String
  identity_in: [String!]
  identity_not_in: [String!]
  identity_lt: String
  identity_lte: String
  identity_gt: String
  identity_gte: String
  identity_contains: String
  identity_not_contains: String
  identity_starts_with: String
  identity_not_starts_with: String
  identity_ends_with: String
  identity_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  role: Role
  role_not: Role
  role_in: [Role!]
  role_not_in: [Role!]
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  profilePic: String
  profilePic_not: String
  profilePic_in: [String!]
  profilePic_not_in: [String!]
  profilePic_lt: String
  profilePic_lte: String
  profilePic_gt: String
  profilePic_gte: String
  profilePic_contains: String
  profilePic_not_contains: String
  profilePic_starts_with: String
  profilePic_not_starts_with: String
  profilePic_ends_with: String
  profilePic_not_ends_with: String
  AND: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  authId: String
  identity: String
  name: String
  todoListsOwned: TodoListUpdateManyWithoutOwnedByInput
  todoListsAssigned: TodoListUpdateManyWithoutAssignedToInput
  inTeam: TeamUpdateManyWithoutMembersInput
  role: Role
  email: String
  phone: String
  profilePic: String
}

input UserUpdateInput {
  authId: String
  identity: String
  name: String
  todoListsOwned: TodoListUpdateManyWithoutOwnedByInput
  todoListsAssigned: TodoListUpdateManyWithoutAssignedToInput
  inTeam: TeamUpdateManyWithoutMembersInput
  role: Role
  email: String
  phone: String
  profilePic: String
}

input UserUpdateManyDataInput {
  authId: String
  identity: String
  name: String
  role: Role
  email: String
  phone: String
  profilePic: String
}

input UserUpdateManyInput {
  create: [UserCreateInput!]
  update: [UserUpdateWithWhereUniqueNestedInput!]
  upsert: [UserUpsertWithWhereUniqueNestedInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyMutationInput {
  authId: String
  identity: String
  name: String
  role: Role
  email: String
  phone: String
  profilePic: String
}

input UserUpdateManyWithoutInTeamInput {
  create: [UserCreateWithoutInTeamInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutInTeamInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutInTeamInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithoutTodoListsAssignedInput {
  create: [UserCreateWithoutTodoListsAssignedInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutTodoListsAssignedInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutTodoListsAssignedInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithoutTodoListsOwnedInput {
  create: [UserCreateWithoutTodoListsOwnedInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutTodoListsOwnedInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutTodoListsOwnedInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput!
  data: UserUpdateManyDataInput!
}

input UserUpdateOneInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutInTeamDataInput {
  authId: String
  identity: String
  name: String
  todoListsOwned: TodoListUpdateManyWithoutOwnedByInput
  todoListsAssigned: TodoListUpdateManyWithoutAssignedToInput
  role: Role
  email: String
  phone: String
  profilePic: String
}

input UserUpdateWithoutTodoListsAssignedDataInput {
  authId: String
  identity: String
  name: String
  todoListsOwned: TodoListUpdateManyWithoutOwnedByInput
  inTeam: TeamUpdateManyWithoutMembersInput
  role: Role
  email: String
  phone: String
  profilePic: String
}

input UserUpdateWithoutTodoListsOwnedDataInput {
  authId: String
  identity: String
  name: String
  todoListsAssigned: TodoListUpdateManyWithoutAssignedToInput
  inTeam: TeamUpdateManyWithoutMembersInput
  role: Role
  email: String
  phone: String
  profilePic: String
}

input UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput!
  data: UserUpdateDataInput!
}

input UserUpdateWithWhereUniqueWithoutInTeamInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutInTeamDataInput!
}

input UserUpdateWithWhereUniqueWithoutTodoListsAssignedInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutTodoListsAssignedDataInput!
}

input UserUpdateWithWhereUniqueWithoutTodoListsOwnedInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutTodoListsOwnedDataInput!
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput!
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithWhereUniqueWithoutInTeamInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutInTeamDataInput!
  create: UserCreateWithoutInTeamInput!
}

input UserUpsertWithWhereUniqueWithoutTodoListsAssignedInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutTodoListsAssignedDataInput!
  create: UserCreateWithoutTodoListsAssignedInput!
}

input UserUpsertWithWhereUniqueWithoutTodoListsOwnedInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutTodoListsOwnedDataInput!
  create: UserCreateWithoutTodoListsOwnedInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  authId: String
  authId_not: String
  authId_in: [String!]
  authId_not_in: [String!]
  authId_lt: String
  authId_lte: String
  authId_gt: String
  authId_gte: String
  authId_contains: String
  authId_not_contains: String
  authId_starts_with: String
  authId_not_starts_with: String
  authId_ends_with: String
  authId_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  identity: String
  identity_not: String
  identity_in: [String!]
  identity_not_in: [String!]
  identity_lt: String
  identity_lte: String
  identity_gt: String
  identity_gte: String
  identity_contains: String
  identity_not_contains: String
  identity_starts_with: String
  identity_not_starts_with: String
  identity_ends_with: String
  identity_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  todoListsOwned_every: TodoListWhereInput
  todoListsOwned_some: TodoListWhereInput
  todoListsOwned_none: TodoListWhereInput
  todoListsAssigned_every: TodoListWhereInput
  todoListsAssigned_some: TodoListWhereInput
  todoListsAssigned_none: TodoListWhereInput
  inTeam_every: TeamWhereInput
  inTeam_some: TeamWhereInput
  inTeam_none: TeamWhereInput
  role: Role
  role_not: Role
  role_in: [Role!]
  role_not_in: [Role!]
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  profilePic: String
  profilePic_not: String
  profilePic_in: [String!]
  profilePic_not_in: [String!]
  profilePic_lt: String
  profilePic_lte: String
  profilePic_gt: String
  profilePic_gte: String
  profilePic_contains: String
  profilePic_not_contains: String
  profilePic_starts_with: String
  profilePic_not_starts_with: String
  profilePic_ends_with: String
  profilePic_not_ends_with: String
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  authId: String
}
`
      }
    